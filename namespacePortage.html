<!--
This file is part of the Ristra portage project.
Please see the license file at the root of this repository, or at:
    https://github.com/laristra/portage/blob/master/LICENSE
-->
<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=edge"/>
    <!-- For Mobile Devices -->
    <meta name="viewport" content="width=device-width, initial-scale=1"/>
    <!-- Font stuff -->
    <link href='https://fonts.googleapis.com/css?family=Roboto+Slab' rel='stylesheet' type='text/css'/>
    <!-- Font Awesome -->
    <!--    <link rel="stylesheet" href="font-awesome-4.3.0/css/font-awesome.min.css"/> -->
    <script src="https://use.fontawesome.com/3dce4d8e65.js"></script>
    <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
    <meta name="generator" content="Doxygen 1.8.13"/>
    <script type="text/javascript" src="https://code.jquery.com/jquery-3.1.1.min.js"></script>
    <title>portage: Portage Namespace Reference</title>
    <script type="text/javascript" src="dynsections.js"></script>
    <link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
    <script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "Tex/AMSmath.js", "Tex/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js"></script>
    <link href="doxygen.css" rel="stylesheet" type="text/css" />
    <link href="customdoxygen.css" rel="stylesheet" type="text/css"/>
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css"/>
    <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js"></script>
    <script type="text/javascript" src="doxy-boot.js"></script>
  </head>
  <body>
    <nav class="navbar navbar-default" role="navigation">
      <div class="container">
        <div class="navbar-header">
          <img src="Portage-logo-small.png" alt="portage">
        </div>
      </div>
    </nav>
    <div id="top"><!-- do not remove this div, it is closed by doxygen! -->
      <div class="content" id="content">
        <div class="container">
          <div class="row">
            <div class="col-sm-12 panel " style="padding-bottom: 15px;">
              <div style="margin-bottom: 15px;">
		<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Portage Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacePortage_1_1Meshfree"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacePortage_1_1Meshfree.html">Meshfree</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPortage_1_1DummyInterfaceReconstructor.html">DummyInterfaceReconstructor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structPortage_1_1facetedpoly.html">facetedpoly</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPortage_1_1Interpolate__1stOrder.html">Interpolate_1stOrder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classPortage_1_1Interpolate__1stOrder.html" title="Interpolate_1stOrder does a 1st order interpolation of scalars. ">Interpolate_1stOrder</a> does a 1st order interpolation of scalars.  <a href="classPortage_1_1Interpolate__1stOrder.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPortage_1_1Interpolate__1stOrder_3_01D_00_01Entity__kind_1_1CELL_00_01SourceMeshType_00_01Ta64ce4468dfaa0ad5e7368da73a88bbe.html">Interpolate_1stOrder&lt; D, Entity_kind::CELL, SourceMeshType, TargetMeshType, StateType, InterfaceReconstructorType, Matpoly_Splitter, Matpoly_Clipper &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classPortage_1_1Interpolate__1stOrder.html" title="Interpolate_1stOrder does a 1st order interpolation of scalars. ">Interpolate_1stOrder</a> specialization for cells.  <a href="classPortage_1_1Interpolate__1stOrder_3_01D_00_01Entity__kind_1_1CELL_00_01SourceMeshType_00_01Ta64ce4468dfaa0ad5e7368da73a88bbe.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPortage_1_1Interpolate__1stOrder_3_01D_00_01Entity__kind_1_1NODE_00_01SourceMeshType_00_01T002b62afef3052729892b73e10ecddab.html">Interpolate_1stOrder&lt; D, Entity_kind::NODE, SourceMeshType, TargetMeshType, StateType, InterfaceReconstructorType, Matpoly_Splitter, Matpoly_Clipper &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classPortage_1_1Interpolate__1stOrder.html" title="Interpolate_1stOrder does a 1st order interpolation of scalars. ">Interpolate_1stOrder</a> specialization for nodes.  <a href="classPortage_1_1Interpolate__1stOrder_3_01D_00_01Entity__kind_1_1NODE_00_01SourceMeshType_00_01T002b62afef3052729892b73e10ecddab.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPortage_1_1Interpolate__2ndOrder.html">Interpolate_2ndOrder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classPortage_1_1Interpolate__2ndOrder.html" title="Interpolate_2ndOrder does a 2nd order interpolation of scalars. ">Interpolate_2ndOrder</a> does a 2nd order interpolation of scalars.  <a href="classPortage_1_1Interpolate__2ndOrder.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPortage_1_1Interpolate__2ndOrder_3_01D_00_01Entity__kind_1_1CELL_00_01SourceMeshType_00_01Tc8f5457db5ede8c340630a5c98395b3e.html">Interpolate_2ndOrder&lt; D, Entity_kind::CELL, SourceMeshType, TargetMeshType, StateType, InterfaceReconstructorType, Matpoly_Splitter, Matpoly_Clipper &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">2nd order interpolate class specialization for cells  <a href="classPortage_1_1Interpolate__2ndOrder_3_01D_00_01Entity__kind_1_1CELL_00_01SourceMeshType_00_01Tc8f5457db5ede8c340630a5c98395b3e.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPortage_1_1Interpolate__2ndOrder_3_01D_00_01Entity__kind_1_1NODE_00_01SourceMeshType_00_01T17875b6c15a8f01147bb8b4f4f168a57.html">Interpolate_2ndOrder&lt; D, Entity_kind::NODE, SourceMeshType, TargetMeshType, StateType, InterfaceReconstructorType, Matpoly_Splitter, Matpoly_Clipper &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">2nd order interpolate class specialization for nodes  <a href="classPortage_1_1Interpolate__2ndOrder_3_01D_00_01Entity__kind_1_1NODE_00_01SourceMeshType_00_01T17875b6c15a8f01147bb8b4f4f168a57.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPortage_1_1Interpolate__3rdOrder.html">Interpolate_3rdOrder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classPortage_1_1Interpolate__3rdOrder.html" title="Interpolate_3rdOrder does a 3rd order interpolation of scalars. ">Interpolate_3rdOrder</a> does a 3rd order interpolation of scalars.  <a href="classPortage_1_1Interpolate__3rdOrder.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPortage_1_1Interpolate__3rdOrder_3_01D_00_01Entity__kind_1_1CELL_00_01SourceMeshType_00_01Ta0dbff458b973aeb20b9316e164becb8.html">Interpolate_3rdOrder&lt; D, Entity_kind::CELL, SourceMeshType, TargetMeshType, StateType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">3rd order interpolate class specialization for cells  <a href="classPortage_1_1Interpolate__3rdOrder_3_01D_00_01Entity__kind_1_1CELL_00_01SourceMeshType_00_01Ta0dbff458b973aeb20b9316e164becb8.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPortage_1_1Interpolate__3rdOrder_3_01D_00_01Entity__kind_1_1NODE_00_01SourceMeshType_00_01Tdf5165583bfa4bb57f3e0ccd90d20bd7.html">Interpolate_3rdOrder&lt; D, Entity_kind::NODE, SourceMeshType, TargetMeshType, StateType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">3rd order interpolate class specialization for nodes  <a href="classPortage_1_1Interpolate__3rdOrder_3_01D_00_01Entity__kind_1_1NODE_00_01SourceMeshType_00_01Tdf5165583bfa4bb57f3e0ccd90d20bd7.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPortage_1_1IntersectClipper.html">IntersectClipper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">2-D intersection algorithm for arbitrary convex and non-convex polyhedra  <a href="classPortage_1_1IntersectClipper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPortage_1_1IntersectR2D.html">IntersectR2D</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">algorithm  <a href="classPortage_1_1IntersectR2D.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPortage_1_1IntersectR2D_3_01Entity__kind_1_1CELL_00_01SourceMeshType_00_01SourceStateType_0b41d87c30c1f1797c002ad34a8f6d94b.html">IntersectR2D&lt; Entity_kind::CELL, SourceMeshType, SourceStateType, TargetMeshType, InterfaceReconstructorType, Matpoly_Splitter, Matpoly_Clipper &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPortage_1_1IntersectR2D_3_01Entity__kind_1_1NODE_00_01SourceMeshType_00_01SourceStateType_0130637de19b54166defbcc76e593b72c.html">IntersectR2D&lt; Entity_kind::NODE, SourceMeshType, SourceStateType, TargetMeshType, InterfaceReconstructorType, Matpoly_Splitter, Matpoly_Clipper &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPortage_1_1IntersectR3D.html">IntersectR3D</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPortage_1_1IntersectR3D_3_01Entity__kind_1_1CELL_00_01SourceMeshType_00_01SourceStateType_06a58bcd4d8cdbdf4ea067835e2db1f86.html">IntersectR3D&lt; Entity_kind::CELL, SourceMeshType, SourceStateType, TargetMeshType, InterfaceReconstructorType, Matpoly_Splitter, Matpoly_Clipper &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPortage_1_1IntersectR3D_3_01Entity__kind_1_1NODE_00_01SourceMeshType_00_01SourceStateType_0aecd96cb58707022f612cdec8b095f81.html">IntersectR3D&lt; Entity_kind::NODE, SourceMeshType, SourceStateType, TargetMeshType, InterfaceReconstructorType, Matpoly_Splitter, Matpoly_Clipper &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPortage_1_1Limited__Gradient.html">Limited_Gradient</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute limited gradient of a field or components of a field.  <a href="classPortage_1_1Limited__Gradient.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPortage_1_1Limited__Gradient_3_01D_00_01Entity__kind_1_1CELL_00_01MeshType_00_01StateType_0a22db2375f5133a3b8b1037e485d394c.html">Limited_Gradient&lt; D, Entity_kind::CELL, MeshType, StateType, InterfaceReconstructorType, Matpoly_Splitter, Matpoly_Clipper &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPortage_1_1Limited__Gradient_3_01D_00_01Entity__kind_1_1NODE_00_01MeshType_00_01StateType_01_4.html">Limited_Gradient&lt; D, Entity_kind::NODE, MeshType, StateType &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPortage_1_1Limited__Quadfit.html">Limited_Quadfit</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute limited quadfit of a field or components of a field.  <a href="classPortage_1_1Limited__Quadfit.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPortage_1_1Limited__Quadfit_3_01D_00_01Entity__kind_1_1CELL_00_01MeshType_00_01StateType_01_4.html">Limited_Quadfit&lt; D, Entity_kind::CELL, MeshType, StateType &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPortage_1_1Limited__Quadfit_3_01D_00_01Entity__kind_1_1NODE_00_01MeshType_00_01StateType_01_4.html">Limited_Quadfit&lt; D, Entity_kind::NODE, MeshType, StateType &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPortage_1_1MismatchFixer.html">MismatchFixer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPortage_1_1MMDriver.html">MMDriver</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classPortage_1_1MMDriver.html" title="MMDriver provides the API to mapping multi-material data from one mesh to another. ">MMDriver</a> provides the API to mapping multi-material data from one mesh to another.  <a href="classPortage_1_1MMDriver.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPortage_1_1MSM__Driver.html">MSM_Driver</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classPortage_1_1MSM__Driver.html" title="MSM_Driver provides the API to mapping from one mesh to another. ">MSM_Driver</a> provides the API to mapping from one mesh to another.  <a href="classPortage_1_1MSM__Driver.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPortage_1_1SearchKDTree.html">SearchKDTree</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A k-d tree search class that allows us to search for control volumes of entities from one mesh (source) that potentially overlap the control volume of an entity from the second mesh (target)  <a href="classPortage_1_1SearchKDTree.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPortage_1_1SearchKDTree_3_01D_00_01Entity__kind_1_1CELL_00_01SourceMeshType_00_01TargetMeshType_01_4.html">SearchKDTree&lt; D, Entity_kind::CELL, SourceMeshType, TargetMeshType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A k-d tree search class (specialization) that allows us to search for cells from one mesh (source) that potentially overlap a cell from the second mesh (target)  <a href="classPortage_1_1SearchKDTree_3_01D_00_01Entity__kind_1_1CELL_00_01SourceMeshType_00_01TargetMeshType_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPortage_1_1SearchKDTree_3_01D_00_01Entity__kind_1_1NODE_00_01SourceMeshType_00_01TargetMeshType_01_4.html">SearchKDTree&lt; D, Entity_kind::NODE, SourceMeshType, TargetMeshType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A k-d tree search class (specialization) that allows us to search for nodes from one mesh (source) whose control volumes potentially overlap the control volumes of a node from the second mesh (target)  <a href="classPortage_1_1SearchKDTree_3_01D_00_01Entity__kind_1_1NODE_00_01SourceMeshType_00_01TargetMeshType_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPortage_1_1SearchPointsByCells.html">SearchPointsByCells</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A simple, crude search algorithm that does a linear-time search over a swarm of points.  <a href="classPortage_1_1SearchPointsByCells.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPortage_1_1SearchSimple.html">SearchSimple</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A simple, crude search algorithm that utilizes bounding boxes in 2d.  <a href="classPortage_1_1SearchSimple.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPortage_1_1SearchSimplePoints.html">SearchSimplePoints</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A simple, crude search algorithm that does a quadratic-time search over a swarm of points.  <a href="classPortage_1_1SearchSimplePoints.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a7e82d75f36b1be4809be45b211b73c82"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structPortage_1_1facetedpoly.html">Portage::facetedpoly</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacePortage.html#a7e82d75f36b1be4809be45b211b73c82">facetedpoly_t</a></td></tr>
<tr class="separator:a7e82d75f36b1be4809be45b211b73c82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad86a06a9372f05948709ca73e058981d"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ad86a06a9372f05948709ca73e058981d"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacePortage.html#ad86a06a9372f05948709ca73e058981d">vector</a> = std::vector&lt; T &gt;</td></tr>
<tr class="separator:ad86a06a9372f05948709ca73e058981d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87dd0ef7473cba89bdb84abf36f00f83"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a87dd0ef7473cba89bdb84abf36f00f83"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacePortage.html#a87dd0ef7473cba89bdb84abf36f00f83">pointer</a> = T *</td></tr>
<tr class="separator:a87dd0ef7473cba89bdb84abf36f00f83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5798f2be664fd95e54414f8aca5e3282"><td class="memItemLeft" align="right" valign="top">typedef boost::counting_iterator&lt; unsigned int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacePortage.html#a5798f2be664fd95e54414f8aca5e3282">counting_iterator</a></td></tr>
<tr class="separator:a5798f2be664fd95e54414f8aca5e3282"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a4cb59edee64edb5a23427c8cb2fb5be6"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacePortage.html#a4cb59edee64edb5a23427c8cb2fb5be6">Limiter_type</a> { <a class="el" href="namespacePortage.html#a4cb59edee64edb5a23427c8cb2fb5be6a129ce73da39e28f090a4963952638f0f">NOLIMITER</a>, 
<a class="el" href="namespacePortage.html#a4cb59edee64edb5a23427c8cb2fb5be6a4f6f1bf6ab0e55d5b828de82c8f618ac">BARTH_JESPERSEN</a>
 }<tr class="memdesc:a4cb59edee64edb5a23427c8cb2fb5be6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Limiter type.  <a href="namespacePortage.html#a4cb59edee64edb5a23427c8cb2fb5be6">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:a4cb59edee64edb5a23427c8cb2fb5be6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14733964cb2a49126b6094ce7cbdeb1e"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacePortage.html#a14733964cb2a49126b6094ce7cbdeb1e">Partial_fixup_type</a> { <a class="el" href="namespacePortage.html#a14733964cb2a49126b6094ce7cbdeb1ea0b44e746b0140c4289ed50512e078c27">CONSTANT</a>, 
<a class="el" href="namespacePortage.html#a14733964cb2a49126b6094ce7cbdeb1ea33c0cfe8c804fc247ef74ecef207dae0">LOCALLY_CONSERVATIVE</a>, 
<a class="el" href="namespacePortage.html#a14733964cb2a49126b6094ce7cbdeb1ea91b68620275b50e4e569956bcae12669">SHIFTED_CONSERVATIVE</a>
 }<tr class="memdesc:a14733964cb2a49126b6094ce7cbdeb1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fixup options for partially filled cells.  <a href="namespacePortage.html#a14733964cb2a49126b6094ce7cbdeb1e">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:a14733964cb2a49126b6094ce7cbdeb1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98e23e534e4657cb05de2e35f5728dad"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacePortage.html#a98e23e534e4657cb05de2e35f5728dad">Empty_fixup_type</a> { <a class="el" href="namespacePortage.html#a98e23e534e4657cb05de2e35f5728dada89f5f07a1a2f7640e0b2b7df079c7f1a">LEAVE_EMPTY</a>, 
<a class="el" href="namespacePortage.html#a98e23e534e4657cb05de2e35f5728dada766b6efbb49a7f24d134f8f016525c28">EXTRAPOLATE</a>, 
<a class="el" href="namespacePortage.html#a98e23e534e4657cb05de2e35f5728dada755f6b45a59532007c37e144211379d0">FILL</a>
 }<tr class="memdesc:a98e23e534e4657cb05de2e35f5728dad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fixup options for empty cells.  <a href="namespacePortage.html#a98e23e534e4657cb05de2e35f5728dad">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:a98e23e534e4657cb05de2e35f5728dad"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a28801231aab794ec2ffa813b3153244e"><td class="memTemplParams" colspan="2">template&lt;int D, class Mesh_Wrapper , class State_Wrapper , class InterfaceReconstructor &gt; </td></tr>
<tr class="memitem:a28801231aab794ec2ffa813b3153244e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacePortage.html#a28801231aab794ec2ffa813b3153244e">write_to_gmv</a> (Mesh_Wrapper const &amp;mesh, State_Wrapper const &amp;state, std::shared_ptr&lt; InterfaceReconstructor &gt; ir, std::vector&lt; std::string &gt; &amp;fieldnames, std::string filename)</td></tr>
<tr class="memdesc:a28801231aab794ec2ffa813b3153244e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Method to write out material polygons from an interface reconstruction and any associated material fields.  <a href="#a28801231aab794ec2ffa813b3153244e">More...</a><br /></td></tr>
<tr class="separator:a28801231aab794ec2ffa813b3153244e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3ac3cce6cea334db05ee5bb0a8dca1b"><td class="memItemLeft" align="right" valign="top">std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacePortage.html#ac3ac3cce6cea334db05ee5bb0a8dca1b">intersect_polys_r2d</a> (std::vector&lt; Wonton::Point&lt; 2 &gt;&gt; const &amp;source_poly, std::vector&lt; Wonton::Point&lt; 2 &gt;&gt; const &amp;target_poly)</td></tr>
<tr class="separator:ac3ac3cce6cea334db05ee5bb0a8dca1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac863df55dc3f0db7ebda6c6fb7ff81b"><td class="memItemLeft" align="right" valign="top">std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacePortage.html#aac863df55dc3f0db7ebda6c6fb7ff81b">intersect_polys_r3d</a> (const <a class="el" href="namespacePortage.html#a7e82d75f36b1be4809be45b211b73c82">facetedpoly_t</a> &amp;srcpoly, const std::vector&lt; std::array&lt; Point&lt; 3 &gt;, 4 &gt;&gt; &amp;target_tet_coords)</td></tr>
<tr class="separator:aac863df55dc3f0db7ebda6c6fb7ff81b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3159778bc5b4b0e5f0f7363576bb2004"><td class="memItemLeft" align="right" valign="top">std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacePortage.html#a3159778bc5b4b0e5f0f7363576bb2004">areaAndMomentPolygon</a> (const std::vector&lt; Wonton::Point&lt; 2 &gt;&gt; poly)</td></tr>
<tr class="memdesc:a3159778bc5b4b0e5f0f7363576bb2004"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the area and moment of the polygon.  <a href="#a3159778bc5b4b0e5f0f7363576bb2004">More...</a><br /></td></tr>
<tr class="separator:a3159778bc5b4b0e5f0f7363576bb2004"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a275382cca2ea6158c4754cdad91eff48"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacePortage.html#a5798f2be664fd95e54414f8aca5e3282">counting_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacePortage.html#a275382cca2ea6158c4754cdad91eff48">make_counting_iterator</a> (unsigned int const i)</td></tr>
<tr class="separator:a275382cca2ea6158c4754cdad91eff48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21890bd61e1c8eccc223e9c8d7fa2904"><td class="memTemplParams" colspan="2">template&lt;typename InputIterator , typename OutputIterator , typename UnaryFunction &gt; </td></tr>
<tr class="memitem:a21890bd61e1c8eccc223e9c8d7fa2904"><td class="memTemplItemLeft" align="right" valign="top">OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacePortage.html#a21890bd61e1c8eccc223e9c8d7fa2904">transform</a> (InputIterator first, InputIterator last, OutputIterator result, UnaryFunction op)</td></tr>
<tr class="separator:a21890bd61e1c8eccc223e9c8d7fa2904"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a580a5424060d461264a7bca8d1b66de6"><td class="memTemplParams" colspan="2">template&lt;typename InputIterator1 , typename InputIterator2 , typename OutputIterator , typename BinaryFunction &gt; </td></tr>
<tr class="memitem:a580a5424060d461264a7bca8d1b66de6"><td class="memTemplItemLeft" align="right" valign="top">OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacePortage.html#a580a5424060d461264a7bca8d1b66de6">transform</a> (InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, OutputIterator result, BinaryFunction op)</td></tr>
<tr class="separator:a580a5424060d461264a7bca8d1b66de6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfead3a555ad7950876fa64b82212be3"><td class="memTemplParams" colspan="2">template&lt;typename InputIterator , typename UnaryFunction &gt; </td></tr>
<tr class="memitem:acfead3a555ad7950876fa64b82212be3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacePortage.html#acfead3a555ad7950876fa64b82212be3">for_each</a> (InputIterator first, InputIterator last, UnaryFunction f)</td></tr>
<tr class="separator:acfead3a555ad7950876fa64b82212be3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="a5798f2be664fd95e54414f8aca5e3282"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5798f2be664fd95e54414f8aca5e3282">&#9670;&nbsp;</a></span>counting_iterator</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef boost::counting_iterator&lt;unsigned int&gt; <a class="el" href="namespacePortage.html#a5798f2be664fd95e54414f8aca5e3282">Portage::counting_iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7e82d75f36b1be4809be45b211b73c82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e82d75f36b1be4809be45b211b73c82">&#9670;&nbsp;</a></span>facetedpoly_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structPortage_1_1facetedpoly.html">Portage::facetedpoly</a>  <a class="el" href="namespacePortage.html#a7e82d75f36b1be4809be45b211b73c82">Portage::facetedpoly_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a87dd0ef7473cba89bdb84abf36f00f83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87dd0ef7473cba89bdb84abf36f00f83">&#9670;&nbsp;</a></span>pointer</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacePortage.html#a87dd0ef7473cba89bdb84abf36f00f83">Portage::pointer</a> = typedef T*</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad86a06a9372f05948709ca73e058981d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad86a06a9372f05948709ca73e058981d">&#9670;&nbsp;</a></span>vector</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacePortage.html#ad86a06a9372f05948709ca73e058981d">Portage::vector</a> = typedef std::vector&lt;T&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a98e23e534e4657cb05de2e35f5728dad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98e23e534e4657cb05de2e35f5728dad">&#9670;&nbsp;</a></span>Empty_fixup_type</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacePortage.html#a98e23e534e4657cb05de2e35f5728dad">Portage::Empty_fixup_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fixup options for empty cells. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a98e23e534e4657cb05de2e35f5728dada89f5f07a1a2f7640e0b2b7df079c7f1a"></a>LEAVE_EMPTY&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a98e23e534e4657cb05de2e35f5728dada766b6efbb49a7f24d134f8f016525c28"></a>EXTRAPOLATE&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a98e23e534e4657cb05de2e35f5728dada755f6b45a59532007c37e144211379d0"></a>FILL&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<a id="a4cb59edee64edb5a23427c8cb2fb5be6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4cb59edee64edb5a23427c8cb2fb5be6">&#9670;&nbsp;</a></span>Limiter_type</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacePortage.html#a4cb59edee64edb5a23427c8cb2fb5be6">Portage::Limiter_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Limiter type. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a4cb59edee64edb5a23427c8cb2fb5be6a129ce73da39e28f090a4963952638f0f"></a>NOLIMITER&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a4cb59edee64edb5a23427c8cb2fb5be6a4f6f1bf6ab0e55d5b828de82c8f618ac"></a>BARTH_JESPERSEN&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<a id="a14733964cb2a49126b6094ce7cbdeb1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14733964cb2a49126b6094ce7cbdeb1e">&#9670;&nbsp;</a></span>Partial_fixup_type</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacePortage.html#a14733964cb2a49126b6094ce7cbdeb1e">Portage::Partial_fixup_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fixup options for partially filled cells. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a14733964cb2a49126b6094ce7cbdeb1ea0b44e746b0140c4289ed50512e078c27"></a>CONSTANT&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a14733964cb2a49126b6094ce7cbdeb1ea33c0cfe8c804fc247ef74ecef207dae0"></a>LOCALLY_CONSERVATIVE&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a14733964cb2a49126b6094ce7cbdeb1ea91b68620275b50e4e569956bcae12669"></a>SHIFTED_CONSERVATIVE&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a3159778bc5b4b0e5f0f7363576bb2004"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3159778bc5b4b0e5f0f7363576bb2004">&#9670;&nbsp;</a></span>areaAndMomentPolygon()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;double&gt; Portage::areaAndMomentPolygon </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; Wonton::Point&lt; 2 &gt;&gt;&#160;</td>
          <td class="paramname"><em>poly</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the area and moment of the polygon. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">poly</td><td>A vector of a pair of (x,y) coordinates of the nodes making up the polygon. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::vector&lt;double&gt;&ndash;area, mx, my </dd></dl>

</div>
</div>
<a id="acfead3a555ad7950876fa64b82212be3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acfead3a555ad7950876fa64b82212be3">&#9670;&nbsp;</a></span>for_each()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIterator , typename UnaryFunction &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Portage::for_each </td>
          <td>(</td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UnaryFunction&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac3ac3cce6cea334db05ee5bb0a8dca1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3ac3cce6cea334db05ee5bb0a8dca1b">&#9670;&nbsp;</a></span>intersect_polys_r2d()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;double&gt; Portage::intersect_polys_r2d </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; Wonton::Point&lt; 2 &gt;&gt; const &amp;&#160;</td>
          <td class="paramname"><em>source_poly</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; Wonton::Point&lt; 2 &gt;&gt; const &amp;&#160;</td>
          <td class="paramname"><em>target_poly</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aac863df55dc3f0db7ebda6c6fb7ff81b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac863df55dc3f0db7ebda6c6fb7ff81b">&#9670;&nbsp;</a></span>intersect_polys_r3d()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;double&gt; Portage::intersect_polys_r3d </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacePortage.html#a7e82d75f36b1be4809be45b211b73c82">facetedpoly_t</a> &amp;&#160;</td>
          <td class="paramname"><em>srcpoly</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::array&lt; Point&lt; 3 &gt;, 4 &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>target_tet_coords</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a275382cca2ea6158c4754cdad91eff48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a275382cca2ea6158c4754cdad91eff48">&#9670;&nbsp;</a></span>make_counting_iterator()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacePortage.html#a5798f2be664fd95e54414f8aca5e3282">counting_iterator</a> Portage::make_counting_iterator </td>
          <td>(</td>
          <td class="paramtype">unsigned int const&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a21890bd61e1c8eccc223e9c8d7fa2904"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21890bd61e1c8eccc223e9c8d7fa2904">&#9670;&nbsp;</a></span>transform() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIterator , typename OutputIterator , typename UnaryFunction &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">OutputIterator Portage::transform </td>
          <td>(</td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UnaryFunction&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a580a5424060d461264a7bca8d1b66de6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a580a5424060d461264a7bca8d1b66de6">&#9670;&nbsp;</a></span>transform() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIterator1 , typename InputIterator2 , typename OutputIterator , typename BinaryFunction &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">OutputIterator Portage::transform </td>
          <td>(</td>
          <td class="paramtype">InputIterator1&#160;</td>
          <td class="paramname"><em>first1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator1&#160;</td>
          <td class="paramname"><em>last1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator2&#160;</td>
          <td class="paramname"><em>first2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BinaryFunction&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a28801231aab794ec2ffa813b3153244e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28801231aab794ec2ffa813b3153244e">&#9670;&nbsp;</a></span>write_to_gmv()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int D, class Mesh_Wrapper , class State_Wrapper , class InterfaceReconstructor &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Portage::write_to_gmv </td>
          <td>(</td>
          <td class="paramtype">Mesh_Wrapper const &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">State_Wrapper const &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; InterfaceReconstructor &gt;&#160;</td>
          <td class="paramname"><em>ir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>fieldnames</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>filename</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Method to write out material polygons from an interface reconstruction and any associated material fields. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">D</td><td>Dimension of problem </td></tr>
    <tr><td class="paramname">Mesh_Wrapper</td><td>A Mesh class </td></tr>
    <tr><td class="paramname">State_Wrapper</td><td>A State Manager class </td></tr>
    <tr><td class="paramname">InterfaceReconstructor</td><td>An Interface Reconstruction class</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mesh</td><td>A mesh object (for mesh topology/geometry queries) </td></tr>
    <tr><td class="paramname">state</td><td>A state object (for field and material queries) </td></tr>
    <tr><td class="paramname">ir</td><td>An interface reconstructor to create material polygons from volume fractions (and optionally material centroids)  List of fields to write out  Name of file to write to </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
<!--
This file is part of the Ristra portage project.
Please see the license file at the root of this repository, or at:
    https://github.com/laristra/portage/blob/master/LICENSE
-->
<!-- HTML footer for doxygen 1.8.8-->
<!-- start footer part -->
</div>
</div>
</div>
</div>
</div>
<!--<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address> -->
<footer id="footer" class="footer">
  <div class="container">
    <div class="row test-muted">
      <div class="footer-row col-md-6">Copyright &copy; 2019
	<a href="http://lanl.gov"> Triad, LLC</a>
	All Rights Reserved.
      </div>
      <div class="footer-row col-md-2">
	<a href="https://github.com/laristra/portage/blob/master/LICENSE">
	  BSD LICENSE
	</a>
      </div>
      <div class="footer-row col-md-2">
	LA-CC-16-084
      </div>
      <div class="footer-row col-md-1">
	<a href="mailto:portage@lanl.gov">
	  <i class="fa fa-envelope-o fa-2x"></i>
	</a>
      </div>
      <div class="footer-row col-md-1">
	<a href="https://github.com/laristra/portage">
	  <i class="fa fa-github fa-2x"></i>
	</a>
      </div>
    </div>
  </div>
</footer>
</body>
</html>
