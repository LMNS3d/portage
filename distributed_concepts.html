<!--
This file is part of the Ristra portage project.
Please see the license file at the root of this repository, or at:
    https://github.com/laristra/portage/blob/master/LICENSE
-->
<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=edge"/>
    <!-- For Mobile Devices -->
    <meta name="viewport" content="width=device-width, initial-scale=1"/>
    <!-- Font stuff -->
    <link href='https://fonts.googleapis.com/css?family=Roboto+Slab' rel='stylesheet' type='text/css'/>
    <!-- Font Awesome -->
    <!--    <link rel="stylesheet" href="font-awesome-4.3.0/css/font-awesome.min.css"/> -->
    <script src="https://use.fontawesome.com/3dce4d8e65.js"></script>
    <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
    <meta name="generator" content="Doxygen 1.8.13"/>
    <script type="text/javascript" src="https://code.jquery.com/jquery-3.1.1.min.js"></script>
    <title>portage: High Level Concepts of Data Distribution During Parallel Remap</title>
    <script type="text/javascript" src="dynsections.js"></script>
    <link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
    <script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "Tex/AMSmath.js", "Tex/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js"></script>
    <link href="doxygen.css" rel="stylesheet" type="text/css" />
    <link href="customdoxygen.css" rel="stylesheet" type="text/css"/>
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css"/>
    <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js"></script>
    <script type="text/javascript" src="doxy-boot.js"></script>
  </head>
  <body>
    <nav class="navbar navbar-default" role="navigation">
      <div class="container">
        <div class="navbar-header">
          <img src="Portage-logo-small.png" alt="portage">
        </div>
      </div>
    </nav>
    <div id="top"><!-- do not remove this div, it is closed by doxygen! -->
      <div class="content" id="content">
        <div class="container">
          <div class="row">
            <div class="col-sm-12 panel " style="padding-bottom: 15px;">
              <div style="margin-bottom: 15px;">
		<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">High Level Concepts of Data Distribution During Parallel Remap </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>When running on multiple processors, <a class="el" href="namespacePortage.html">Portage</a> uses a simple data distribution algorithm derived from the work of Slattery, Wilson, &amp; Pawlowski[1] and Plimpton, Hendrickson, &amp; Stewart[2].</p>
<p>The following description applies specifically to mesh-mesh remap. Redistribution of source swarms is similar, but must take into account the support of particles (in the form of smoothing lengths) while computing bounding boxes.</p>
<p>For the purposes of this document, distributed remap begins with the call to <code>remap_distributed(...)</code> within the basic driver call of <code>driver.run(distributed)</code>. Each processor node has a partition of both the source and target meshes. The spatial extent of the source and target meshes on a given partition need not have any special relationship. <a class="el" href="namespacePortage.html">Portage</a> uses polytopal intersections of the overlap between source and target cells (or dual cells in the case of nodal remap) to compute interpolated field values. From this point forward we will use the word "cell" to refer to either a cell in cell-based remap or a dual cell in node-based remap.</p>
<p>In order for each target cell to compute interpolated field values it is necessary to know the geometries of all source cells that intersect it. This presents a problem when the source mesh on a partition does not cover the target mesh on that partition. The essence of <a class="el" href="namespacePortage.html">Portage</a>'s data distribution is to bring all source cells that <em>could</em> intersect the target cells on a particular partition onto that target partition. In <code>remap_distributed(...)</code>, data distribution is the first nontrivial thing done so that the "search" step has all the data necessary to work correctly. <a class="el" href="namespacePortage.html">Portage</a>'s paradigm of "search, intersect, interpolate" requires that any source cells that could potentially intersect a target cell be available for computation on that target cell's partition. After data distribution, each processor node operates exactly as if it were a serial problem. This is the explanation of <a class="el" href="namespacePortage.html">Portage</a>'s embarrasingly parallel characterization. <br />
 </p><div class="image">
<img src="distribution.png" alt="distribution.png"/>
</div>
<p> <br />
 <a class="el" href="namespacePortage.html">Portage</a> uses a simple algorithm for data distribution. A bounding box is computed for the source and target meshes on each partition. An MPI_Bcast is used to distribute the bounding boxes from all target meshes to each source partition. Bounding box intersections determine the processors to which each processor must send its source partition. In the figure above, the numbered red squares represent the bounding boxes for the partitions of a nominal source mesh. The numbered blue rectangles represent the bounding boxes for the partitions of a nominal target mesh. As seen in the figure, the source and target meshes do not need to coincident. In this remap problem, target partition 1 would receive data from source partitions 5, 6, 8, and 9; target partition 2 would receive data from source partitions 4, 5, 7, and 8, etc.</p>
<p>The same communication topology is used for all subsequent data communication. While sending the entire source partition to a target partition that may need only a few of the source cells is somewhat inefficient, it is easy to implement.</p>
<p>Many pieces of data are sent from souce partition to target partition. For each of these pieces of information, two MPI calls need to be made. The first call establishes the counts of the data that will be sent. The second MPI call does the actual data distribution.</p>
<p>It is worthwhile to note that most data is sent making a distinction between ghost cells and owned cells. Both ghost and owned data are sent in the same request, but the counts are kept separately and the sent data is ordered by owned data first followed by ghost data.</p>
<p>The data distributed for remap includes global ids for all entities, node coordinates, adjacency information within the mesh, and field values, which is potentially multi-material. There are many subtleties in distributing the data. The four most important of which are removing duplicates, converting local references, handling vector data, and field data that is multi-material.</p>
<p>The first subtlety is that because of the way that distribution is handled, namely whole patches are sent, the same cell may be received from multiple ranks. A cell may be owned by only one rank, but may also be a ghost on multiple other ranks. A cell may also only exist as a ghost on any rank. The duplicates are eliminated using the global ids of entities that are sent along with the mesh information. Additionally, if a duplicate entity was owned on any partition that it came from, it is considered owned on this partition.</p>
<p>The second subtlety is that each reference in the adjacency data is represented inherently by local references (local ids). The same global id for each mesh entity (cells, faces, and nodes) can be used to update the references to the new indexing scheme on the partition.</p>
<p>The third subtlety is that MPI data transfer only works with sending vectors of uniform type. So any data transfer needs to conform to this description. In other words, if we need to transfer data that is inherently itself vector data, such as a cell centroid, it must first be "flattened" to a vector of doubles where the individual components of the cell's data are listed in order. Such data must be serialized to the form (e.g. in 2D) </p><div class="fragment"><div class="line">(x1, y1, x2, y2, ..., xn, yn).</div></div><!-- fragment --><p> Upon arrival on the target mesh, the data must then be deserialized to the original vector form, still with duplicates removed.</p>
<p>The final subtlety is that multi-material fields greatly complicate data distribution. Multi-material data in <a class="el" href="namespacePortage.html">Portage</a> is stored in material-centric form, meaning a vector of cells and cell data is kept for each material. Material-centric data is composed of cell indices: </p><div class="fragment"><div class="line">material 1: cell_id_1, cell_id_3, ...</div><div class="line">material 2: cell_id_1, cell_id_4, ...</div><div class="line">...</div></div><!-- fragment --><p> with similarly shaped field values: </p><div class="fragment"><div class="line">material 1: x11, x13, ...</div><div class="line">material 2: x21, x24, ...</div><div class="line">...</div></div><!-- fragment --><p> Where in the various <code>xij's</code>, the <code>x</code> data corresponds to material <code>i</code> in cell <code>j</code>. Multi-material data greatly complicates the bookkeeping of data distribution because each material acts like it's own mini-mesh. All multi-material fields are assumed to share the same set of material cells. This implies that if a material exists in a cell, all multi-material field values must be known for that material in that cell.</p>
<p>Distributing multi-material field data requires sending, for each partition, the number of materials, the material ids, the number of cells having each material, the cell ids, and finally the data itself. Just as with all other data, since MPI can handle only vectors of uniform type, each of these "ragged right" data structures must be serialized to vectors of common type on the source partition before sending and deserialized from vectors to the ragged right form required by <a class="el" href="namespacePortage.html">Portage</a>. Finally, multi-material data is inherently more complicated because of its shape but we still need to remove duplicated data and update local ids to the new partition.</p>
<p><br />
</p>
<p>[1] Plimpton, Hendrickson, &amp; Stewart. (2004). A parallel rendezvous algorithm for interpolation between multiple grids. Journal of Parallel and Distributed Computing, 64(2), 266-276.</p>
<p>[2] Slattery, S., Wilson, P., &amp; Pawlowski, R. (2013). The Data Transfer Kit: A geometric rendezvous-based tool for multiphysics data transfer. International Conference on Mathematics and Computational Methods Applied to Nuclear Science and Engineering, M and C 2013, 2, 1262-1272. </p>
</div></div><!-- contents -->
<!--
This file is part of the Ristra portage project.
Please see the license file at the root of this repository, or at:
    https://github.com/laristra/portage/blob/master/LICENSE
-->
<!-- HTML footer for doxygen 1.8.8-->
<!-- start footer part -->
</div>
</div>
</div>
</div>
</div>
<!--<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address> -->
<footer id="footer" class="footer">
  <div class="container">
    <div class="row test-muted">
      <div class="footer-row col-md-6">Copyright &copy; 2019
	<a href="http://lanl.gov"> Triad, LLC</a>
	All Rights Reserved.
      </div>
      <div class="footer-row col-md-2">
	<a href="https://github.com/laristra/portage/blob/master/LICENSE">
	  BSD LICENSE
	</a>
      </div>
      <div class="footer-row col-md-2">
	LA-CC-16-084
      </div>
      <div class="footer-row col-md-1">
	<a href="mailto:portage@lanl.gov">
	  <i class="fa fa-envelope-o fa-2x"></i>
	</a>
      </div>
      <div class="footer-row col-md-1">
	<a href="https://github.com/laristra/portage">
	  <i class="fa fa-github fa-2x"></i>
	</a>
      </div>
    </div>
  </div>
</footer>
</body>
</html>
