<!--
This file is part of the Ristra portage project.
Please see the license file at the root of this repository, or at:
    https://github.com/laristra/portage/blob/master/LICENSE
-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
    <meta http-equiv="X-UA-Compatible" content="IE=edge"/>
    <meta name="generator" content="Doxygen 1.8.13"/>
    <!-- For Mobile Devices -->
    <meta name="viewport" content="width=device-width, initial-scale=1"/>
    <!-- Font stuff -->
    <link href='//fonts.googleapis.com/css?family=Roboto+Slab' rel='stylesheet' type='text/css'/>
    <script src="//use.fontawesome.com/3dce4d8e65.js"></script>
    <!-- the default version jquery provided by doxygen is too old for bootstrap
	 but it also contains local modifications.  we have extracted those that
	 are needed so that we can use a newer jquery. -->
    <!-- <script type="text/javascript" src="//code.jquery.com/jquery-3.1.1.min.js"></script> -->
    <script
			  src="//code.jquery.com/jquery-3.3.1.min.js"
			  integrity="sha256-FgpCb/KJQlLNfOu91ta32o/NMZxltwRo8QtmkMRdAu8="
			  crossorigin="anonymous"></script>
      <!-- <script src="//code.jquery.com/jquery-3.3.1.min.js" integrity="sha384-q8i/X+965DzO0rT7abK41JStQIAqVgRVzpbzo5smXKp4YfRvH+8abtTE1Pi6jizo" crossorigin="anonymous"></script> -->
    <script type="text/javascript" src="smartmenu.js"></script>
    <title>portage: Concepts</title>
    <link href="tabs.css" rel="stylesheet" type="text/css">
      <!-- this version is too old for bootstrap, but it includes modifications
	   from standard jquery
    <script type="text/javascript" src="jquery.js"></script>  -->
    <script type="text/javascript" src="dynsections.js"></script>
    <script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js"></script>
    <link href="doxygen.css" rel="stylesheet" type="text/css" />
    <link href="customdoxygen.css" rel="stylesheet" type="text/css"/>
    <link rel="stylesheet" href="//stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous">
<script src="//cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.7/umd/popper.min.js" integrity="sha384-UO2eT0CpHqdSJQ6hJty5KVphtPhzWj9WO1clHTMGa3JDZwrnQq4sF86dIHNDz0W1" crossorigin="anonymous"></script>
<script src="//stackpath.bootstrapcdn.com/bootstrap/4.3.1/js/bootstrap.min.js" integrity="sha384-JjSmVgyd0p3pXB1rRibZUAYoIIy6OrQ6VrjIEaFf/nJGzIxFDsf4x0xIM+B07jRM" crossorigin="anonymous"></script>
    <!-- <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css"/> -->
    <!-- <script src="//maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js"></script> -->
  </head>
  <body>
    <nav class="navbar navbar-default" role="navigation">
      <div class="container">
        <div class="navbar-header">
          <img src="Portage-logo-small.png" alt="portage">
        </div>
      </div>
    </nav>
    <div id="top"><!-- do not remove this div, it is closed by doxygen! -->
      <div class="content" id="content">
        <div class="container">
          <div class="row">
            <div class="col-sm-12 panel " style="padding-bottom: 15px;">
              <div style="margin-bottom: 15px;">
      		<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',false,false,'search.php','Search');
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Concepts </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h2>Design Principle</h2>
<p><a class="el" href="namespacePortage.html">Portage</a> is a framework for creating custom remappers from interoperable components and not a monolithic, catch-all remapping library. It is designed such that its major components can be mixed and matched as necessary as long as they adhere to an interface. Its design also seeks to minimize the amount of mesh and field data that must be copied from clients in order to minimize data movement.</p>
<div class="image">
<img src="portage-tangram-diagram.png" class="fullwidth" alt="Portage design"/>
</div>
<p> <br />
</p>
<p>In order to enable this DIY design, <a class="el" href="namespacePortage.html">Portage</a> requires the remap driver to be templated on all its component classes implementing the necessary methods. It also requires the driver to be templated on the mesh and state managers for the source and target respectively. The individual components are also templated on the mesh and state managers in turn. Each component is required to be designed as a <a href="https://stackoverflow.com/questions/356950/what-are-c-functors-and-their-uses"><em>functor</em></a>, or in other words, a struct/class with an <code>operator()(...)</code> that is functional, i.e. has no side effects.</p>
<p>The functional design allows a remap driver to be written such that populating the fields on target entities is a nearly embarrassingly parallel process on-node. Remapping on distributed meshes/swarms is also embarrassingly parallel as long as the target and source partitioning is geometrically matching. On the other hand, if there is a geometric mismatch of the partitioning on the source and target, i.e., source entities overlapping a target entity are on a different node, <a class="el" href="namespacePortage.html">Portage</a> performs some communication and data movement in order to get source mesh cells onto partitions needing them. Once this step is concluded at the outset, the remap still shows excellent scaling. More details are given in the <a class="el" href="distributed_concepts.html">High Level Concepts of Data Distribution During Parallel Remap</a> section and performance plots are shown in the scaling section.</p>
<p><a class="anchor" id="Drivers-Apps"></a> </p><h2>Drivers and Applications</h2>
<p><a class="el" href="namespacePortage.html">Portage</a> does come with some full-featured <em>drivers</em> that can be directly used to deploy a powerful remapping capability into an application. In particular, the following drivers are provided:</p>
<ul>
<li><a class="el" href="classPortage_1_1MMDriver.html" title="MMDriver provides the API to mapping multi-material data from one mesh to another. ">Portage::MMDriver</a> - for single- and multi-material mesh-mesh remap.</li>
<li>Portage::swarm::SwarmDriver - for particle-particle remap.</li>
<li><a class="el" href="classPortage_1_1MSM__Driver.html" title="MSM_Driver provides the API to mapping from one mesh to another using particles. ">Portage::MSM_Driver</a> - for mesh-mesh remap with particles as an intermediary.</li>
</ul>
<p>These drivers are all used within some example applications within the <code>apps</code> directory to illustrate how the drivers can be used with a mix of components. The applications choose a particular mesh or particle swarm type, select component classes for the remapping steps along with associated settings for the remap process. The drivers, apps and the regression tests included with the apps are all fairly comprehensive and exercise all functionality of the <a class="el" href="namespacePortage.html">Portage</a> framework. Therefore, the included drivers and some of the apps can be used as-is if they meet all the needs of a particular application.</p>
<h2>Mesh/Particle and State data</h2>
<p>The remapping problem starts with a <em>source</em> mesh (or particle swarm) with field data and a <em>target</em> mesh (or particle swarm) onto which the data must be remapped. For meshes, the field data can live on cell centers or on nodes; particle data naturally lives on particles which can have various shapes and smoothing lengths.</p>
<p>All of <a class="el" href="namespacePortage.html">Portage</a>'s components work directly (to the extent possible - see <a class="el" href="distributed_concepts.html">High Level Concepts of Data Distribution During Parallel Remap</a>) with an application's mesh/particle data and field data respectively. <a class="el" href="namespacePortage.html">Portage</a> accesses this data through <em>mesh</em> (or <em>swarm</em>) and <em>state wrapper classes</em> that provide an interface to the queries needed to perform any particular step. For an illustration of the use of the wrappers in <a class="el" href="namespacePortage.html">Portage</a>, see the <a class="el" href="example.html">Example Use</a> page. More details about the requirements of mesh and state wrappers are given in the documentation of the support package, <a href="https://github.com/laristra/wonton">Wonton</a>.</p>
<p><a class="anchor" id="mesh-mesh remap"></a> </p><h2>Single Material Mesh-Mesh Remapping</h2>
<p>The remapping algorithm within <a class="el" href="namespacePortage.html">Portage</a> for <em>single</em> material problems between two meshes [1][2] is divided into four phases (described here for cell-based fields):</p>
<ul>
<li><b>search</b> - find candidate source cells that will contribute to remap of each target cell</li>
<li><b>intersect</b> - calculate the weight of each candidate's contribution to the remap of a given target cell</li>
<li><b>interpolate</b> - using the weights and source field data reconstruct the field data for each target cell</li>
<li><b>repair</b> - repair the remapped field due to errors resulting from mismatch of the two mesh boundaries</li>
</ul>
<table style="width:100%">
<tr>
<td valign="top"><div class="image">
<object type="image/svg+xml" data="meshmesh.svg" alt="Mesh-mesh" class="fullwidth"></object>
</div>
 </td><td width="4%"></td><td valign="top"><div class="image">
<object type="image/svg+xml" data="search.svg" alt="search" class="fullwidth"></object>
</div>
 </td><td width="4%"></td><td valign="top"><div class="image">
<object type="image/svg+xml" data="intersect.svg" alt="intersect" class="fullwidth"></object>
</div>
 </td><td width="4%"></td><td valign="top"><div class="image">
<object type="image/svg+xml" data="interpolate.svg" alt="interpolate" class="fullwidth"></object>
</div>
  </td></tr>
<tr>
<td width="22%" valign="top">A mesh-mesh configuration. Blue is target mesh, black is source mesh. </td><td width="4%"></td><td width="22%" valign="top">Candidates are in yellow. </td><td width="4%"></td><td width="22%" valign="top">The exact intersectiion volumes are in green. </td><td width="4%"></td><td width="22%" valign="top">The intersection weights are combined to interpolate data in the target cell.  </td></tr>
</table>
<p>The schematic above shows the algorithm when each target cell has access to all source cells that overlap it. As mentioned above, an initial source redistribution step (see <a class="el" href="distributed_concepts.html">High Level Concepts of Data Distribution During Parallel Remap</a>) must be executed if the source and target mesh partitions are not geometrically aligned.</p>
<h3>Search</h3>
<p>Given source and target entities, this step simply <em>identifies</em> which source mesh entities might contribute to each target mesh entity. Concretely, for exact intersection based remap of cell fields, this step identifies which source cells potentially overlap each target cell.</p>
<p><a class="el" href="namespacePortage.html">Portage</a> makes available the following search algorithms with varying degrees of sophistication/speed:</p>
<ul>
<li><a class="el" href="classPortage_1_1SearchSimple.html" title="A simple, crude search algorithm that utilizes bounding boxes in 2d. ">Portage::SearchSimple</a> - 2d, bounding box search</li>
<li><a class="el" href="classPortage_1_1SearchKDTree.html" title="A k-d tree search class that allows us to search for control volumes of entities from one mesh (sourc...">Portage::SearchKDTree</a> - 2d or 3d, k-d tree search (not a true parallel k-d tree)</li>
</ul>
<p>Application developers may use their own search algorithms (like a quadtree or hashed octree algorithm).</p>
<h3>Intersect</h3>
<p>This step calculates the contribution weights from the candidate source cells to a target cell. <a class="el" href="namespacePortage.html">Portage</a> currently uses exact intersection methods to calculate various <em>moments</em> of the polygon/polyhedron of intersection. First order accurate remap needs only the 0th moments (area/volume) of intersection but second order remap requires the 1st moments (effectively, the centroids of the intersection polyhedra).</p>
<p>The available intersectors for meshes in <a class="el" href="namespacePortage.html">Portage</a> are:</p>
<ul>
<li><a class="el" href="classPortage_1_1IntersectClipper.html" title="2-D intersection algorithm for arbitrary convex and non-convex polyhedra ">Portage::IntersectClipper</a> - 2d, exact intersection method based on the <a href="www.angusj.com/delphi/clipper.php">Clipper</a> library for polygon intersection and clipping (Unit tested in <a class="el" href="namespacePortage.html">Portage</a> but not used widely in the App tests)</li>
<li><a class="el" href="classPortage_1_1IntersectR2D.html" title="algorithm ">Portage::IntersectR2D</a> - 2d, fast, exact polygonal intersection method based on the <a href="https://github.com/laristra/r3d, 
  https://github.com/devonmpowell/r3d.git(commit d6799a58)">r3d</a> library.</li>
<li><a class="el" href="classPortage_1_1IntersectR3D.html">Portage::IntersectR3D</a> - 3d, fast, exact polyhedral intersection method based on the <a href="https://github.com/laristra/r3d,
  https://github.com/devonmpowell/r3d.git(commit d6799a58)">r3d</a> library.</li>
</ul>
<p><em>The R2D/R3D-based intersectors in <a class="el" href="namespacePortage.html">Portage</a> are capable of intersecting two non-convex cells based on the ability of R2D/R3D to clip non-convex polygons/polyhedra. Therefore, in <a class="el" href="namespacePortage.html">Portage</a>'s intersectors source mesh cells are left as is regardless of whether they are convex or non-convex but target cells are decomposed into simplices and the simplices intersected with the source cells (unless they are explicitly told that the target cells are strictly convex). The simplices are derived from the side/wedge data structures built by Wonton::AuxMeshTopology class. Note that <a class="el" href="namespacePortage.html">Portage</a> considers hexahedral cells (or any higher polyhedra) with curved faces also as non-convex. When remapping multi-material fields, a source mesh should consist of at least star-convex cells. General non-convex cells would require a different simplex decomposition method in Wonton::AuxMeshTopology class.</em></p>
<p>Applications can choose to supply their own exact cell-cell intersectors or even an alternate algorithm such as the <em>swept face</em> calculation of contributions from source to target cells sometimes used in Arbitrary-Lagrangian-Eulerian methods.</p>
<h3>Interpolate</h3>
<p>Given the source field data, along with the list of source cells and their contribution weights to each target cell, the interpolate step actually populates the field on the target cells. The first order accurate interpolation is simply a weighted sum of the source field values, where the weights are the intersection volumes of the target cells with the source mesh. For second order accurate interpolation, a local linear reconstruction of the source field based on a least squares gradient is used to compute more accurate contributions to the target cell. Local bounds preservation may be enforced using limited gradients (see <a class="el" href="namespacePortage.html#a4cb59edee64edb5a23427c8cb2fb5be6" title="Limiter type. ">Portage::Limiter_type</a>) - this ensures that the remapped value in any target cell will be bounded by the cell values of any intersecting source cells and their immediate neighbors. At domain boundaries, however, limiting <em>can</em> be ill-posed if there are no boundary conditions; we currently do not support such boundary conditions, so we do not limit at domain boundaries. The linear reconstruction requires knowledge of the first moments or centroids of the intersection volumes.</p>
<p>The current interpolation methods for meshes are the following:</p>
<ul>
<li><a class="el" href="classPortage_1_1Interpolate__1stOrder.html" title="Interpolate_1stOrder does a 1st order interpolation of scalars. ">Portage::Interpolate_1stOrder</a> - 1st order accurate, reproduces a constant field.</li>
<li><a class="el" href="classPortage_1_1Interpolate__2ndOrder.html" title="Interpolate_2ndOrder does a 2nd order interpolation of scalars. ">Portage::Interpolate_2ndOrder</a> - 2nd order accurate, reproduces a linear field.</li>
</ul>
<p>As with search and intersect components, applications can furnish their custom interpolation methods.</p>
<p><br />
</p>
<p>For remapping node fields, <a class="el" href="namespacePortage.html">Portage</a> uses the dual cells of the mesh to perform the remapping steps. <em>Note that the use of 2nd order interpolation to node fields is not guaranteed to preserve linear fields or give second order accurate results.</em> This is because for the method to be second-order accurate the linear reconstruction in the source cell (or dual cell) is with respect to the field value at its centroid; for the dual mesh, however, the field values are known at the nodes, not necessarily the centroids of the dual cells. Also, dual cells in a general mesh are almost guaranteed to be non-convex. Therefore, intersection of dual cells always includes a decomposition of the target dual cell into simplices based on wedges/corners in Wonton::AuxMeshTopology.</p>
<p><a class="el" href="namespacePortage.html">Portage</a> currently does not have an algorithm in place for remapping nodal fields to cells and vice-versa although a driver to do such a thing can be written easily.</p>
<h3>Mismatch Fixup or Repair</h3>
<p>Often, the boundaries of the source and target meshes in simulations do not exactly match up. This may happen because curved boundaries are discretized with different resolutions in the two meshes or because two physics packages view the geometry of the domain a bit differently. If all of the source mesh is not covered by the target mesh or vice versa, the result may violate conservation or introduce artifacts in the fields. Therefore, in this step the field is repaired by one of several methods as described in the MismatchFixup" section. The options for handling fully empty cells are in the enum <a class="el" href="namespacePortage.html#a98e23e534e4657cb05de2e35f5728dad" title="Fixup options for empty cells. ">Portage::Empty_fixup_type</a> and the options for repair of partially covered cells are in the enum <a class="el" href="namespacePortage.html#a14733964cb2a49126b6094ce7cbdeb1e" title="Fixup options for partially filled cells. ">Portage::Partial_fixup_type</a>.</p>
<p><br />
</p>
<p><a class="anchor" id="mesh-mesh mmremap"></a> </p><h2>Multi-material remapping</h2>
<p><a class="el" href="namespacePortage.html">Portage</a> is also capable of remapping fields for a sparse multi-material problem, one in which the source mesh has cells possibly containing more than one material but not all materials occur in every cell [3]. The materials in each cell are specified by their volume fractions and optionally, by their centroids. Each multi-material field on the source mesh has as many values in a cell as there are materials in the cell. <em>Multi-material remapping cannot be used with particle swarms nor does it make sense for nodal field remap</em>.</p>
<p>The algorithm for multi-material remapping involves the use of an external interface reconstruction package called <a href="https://github.com/laristra/tangram">Tangram</a> to perform reconstruction of pure material polygons within each cell using the volume fraction (and possibly centroid) data. Tangram is designed similar to <a class="el" href="namespacePortage.html">Portage</a> in that one can use it with default or custom components. It has within its suite of methods Volume-of-fluid and Moment-of-fluid methods.</p>
<p>The algorithm for remapping of multi-material fields is broadly similar to the single material remap but now the intersection and interpolation must be done per material. Thus the algorithm can be roughly described as below:</p>
<ul>
<li><b>search</b> - find candidate cells that will contribute to each target cell</li>
<li><b>interface reconstruct</b> - given volume fractions of materials (and optionally, centroids) on the source mesh, compute a subdivision of each source cell into pure material polygons</li>
<li>For each material <em>m</em> in problem:<ol type="1">
<li><b>intersect</b> - calculate the contribution of material <em>m</em> from each candidate cell to a given target cell. This is done by intersecting the material <em>m</em>'s reconstructed polygon (if it exists) in the source cell with the target cell</li>
<li><b>populate materials</b> - based on intersection moments, determine the cells in which this material appears</li>
<li><b>interpolate</b> - using the intersection weights and moments, along with appropriate limiters, reconstruct the field data for material <em>m</em> for a given target cell. No limiting is performed at material interfaces</li>
<li><b>repair</b> - repair the remapped field due to errors resulting from mismatch of the two mesh boundaries (<em>not yet implemented</em>)</li>
</ol>
</li>
</ul>
<p>Remap of mesh fields on cells and nodes (one value per cell or node) proceeds as in the single material case.</p>
<p>The above steps describe what is called a <em>material-dominant loop</em> - the outer loop is over materials and within each iteration all cells containing this material are processed. Also note that, for a particular field, the interpolate step requests a <em>contiguous field data</em> corresponding to <em>all cells in a particular material</em> (See Wonton documentation for details of the programming interface).</p>
<p>We recognize that not all applications store their fields in the same way. A few store field data in a <em>full data structure</em> wherein field values are stored for every material in the problem in every cell. Most applications store this data compactly in <em>cell-centric</em> or <em>material-centric</em> representations. In the <em>cell-centric</em> form, each cell keeps track of which materials it has and the field values corresponding to those materials. On the other hand, <em>material-centric</em> data representations maintain lists of cells that contain a particular material (or put another way, the cells that a material contains) and track the field values of the material cells. These differences have strong implications for which loops (cell-dominant or material-dominant) work best for each storage pattern.</p>
<p>Based on a study [4] of multi-material data structures, the <a class="el" href="namespacePortage.html">Portage</a> team has concluded that a material dominant loop for remapping is likely to be more cache-friendly and therefore, more performant since this is a memory bound algorithm. The team also has designed the state wrappers to retrieve data in a material-centric way, based on the same study's conclusion that accessing cell-centric data in material-dominant loops and vice versa is highly detrimental to performance. <b>Therefore, we recommend that the field data be transformed, if necessary, within the state wrapper to a material-centric form before remapping and believe that the cost of this transformation will be less than that of accessing the data in an inefficient way.</b></p>
<div class="image">
<object type="image/svg+xml" data="mmremap.svg">mmremap.svg</object>
<div class="caption">
Multi-material remapping with interface reconstruction</div></div>
<p> <br />
</p>
<h2>Swept-face approximate remapping</h2>
<p>In addition to the remap using mesh-mesh intersections, <a class="el" href="namespacePortage.html">Portage</a> offers an approximate method [1] to calculate contribution weights from the candidate source cells. This method is called swept-face method, because the mesh-mesh intersections are replaced by simple regions defined by the displacement of faces between a source mesh and a target mesh. Therefore, this method requires that both meshes have the same topology and only small nodal displacement.</p>
<h3>Single material remap</h3>
<div class="image">
<img src="swept_single_small.png" alt="swept_single_small.png"/>
<div class="caption">
Example of two single-material swept regions</div></div>
<p> Following four phases described earlier, namely: <b>search</b>, <b>intersect</b>, <b>interpolate</b> and <b>repair</b>, the main difference lies inside the <b>intersect</b> phase. The swept-face <b>intersect</b> algorithm can be summarized as:</p>
<ul>
<li>For each face <em>f</em> of a computational cell <em>c</em>, create a swept-face polygon/polyhedron and calculate its signed volume. Note that the polygon can be self-intersecting.</li>
<li>Based on the sign of the volume, assign this volume (and higher moments) either to the cell <em>c</em> or to a neighboring cell which is sharing the face <em>f</em> with the cell <em>c</em>.</li>
<li>In addition to contributions from the face displacement, the volume of the cell <em>c</em> itself is assigned to the cell <em>c</em>, so that the target data can be expressed as a weighted sum over all these contributions in the same way as for the default exact intersections. Therefore, the <b>interpolate</b> phase is the same as for intersection based remap.</li>
</ul>
<p>Thanks to the same connectivity of a source mesh and a target mesh, the <b>search</b> phase is trivial. A list of face-neighboring cells is created in this phase. <b>Repair</b> phase is the same as for the default intersection-based remap.</p>
<h3>Multi material remap</h3>
<div class="image">
<img src="swept_multi_small.png" alt="swept_multi_small.png"/>
<div class="caption">
Example of two multi-material swept regions</div></div>
<h6>An example of two swept regions projected into their corresponding face-cell groups for a multi-material remap</h6>
<p>Preservation of material volumes requires more sophisticated method for the multi-material swept-face remap. To make use of interface reconstruction in source cells, swept regions are projected into corresponding cells based on their signed volumes. This is done in following steps during the <b>intersect</b> phase:</p>
<ul>
<li>Create a polygon/polyhedron <em>p</em> by adding a centroid of a cell <em>c</em> to a face <em>f</em>. This poly defines a face-cell group <em>fc</em>.</li>
<li>Find a cutting plane in the direction of an effective normal of the face <em>f</em> in such a way that the volume of the poly <em>p</em> under the plane is equal to the the swept volume.</li>
<li>Cut material polygons associated with a face-cell group <em>fc</em> with the cutting plane to get material volumes (and higher moments) which are assigned to the cell <em>c</em>. Material volumes from the cell itself have to be added to the contribution as described in the single-material case.</li>
</ul>
<p><br />
</p>
<p><a class="anchor" id="meshfree remap"></a> </p><h2>Particle or swarm Remapping</h2>
<p><a class="el" href="namespacePortage.html">Portage</a> can estimate functions and derivatives between particle swarms (groups of particles) employing algorithmic devices similar to those of mesh-mesh remap. We say "estimate" instead of "interpolate" because in general, meshfree function estimates pass <em>near</em> the data, and not <em>through</em> it. swarm remap is performed in the following steps that echo those of mesh-mesh remapping:</p>
<ul>
<li><b>search</b> - find candidate source particles that will contribute to remap at each target particle.</li>
<li><b>accumulate</b> - calculate the weight of each candidate's contribution to the remap at a given target particle.</li>
<li><b>estimate</b> - using the weights reconstruct the field data for a given target particle.</li>
</ul>
<p>The following figure illustrates typical source and target swarms used for remapping. There are no lines connecting data points. </p><table style="width:100%">
<tr>
<td valign="top"><div class="image">
<img src="swarm_swarm.png" alt="Swarm-swarm" width="33%"/>
</div>
  </td></tr>
<tr>
<td width="22%" valign="top">A swarm-swarm remap configuration. Blue is source, red is target.  </td></tr>
</table>
<p>There are many possible meshfree methods to choose from. <a class="el" href="namespacePortage.html">Portage</a> currently employs the Kernel Density Estimator (KDE), the basis of the Smooth-Particle Hydrodynamics method (SPH), and the well developed Local Regression Estimator (LRE) [5][6]. If LRE is performed with sufficient point density, one can obtain weights for arbitrary orders of derivatives of the field data enabling higher-order estimation of fields. It can even be used to estimate integral operators of the field data on small domains. It has many exceptional properties that render it useful and practical.</p>
<h3>Search</h3>
<p>For particle swarms, the search concepts are similar, with one imporant difference. With meshes, the region of influence of a data point is given by the cell that includes or is connected to it. With particles, the region of influence of a data point is determined by the support of a weight function that includes it. A typical weight function is positive, smooth and unimodal, with compact support, as shown below.</p>
<table style="width:100%">
<tr>
<td valign="top"><div class="image">
<img src="kernel.png" alt="Kernel" width="33%"/>
</div>
  </td></tr>
<tr>
<td width="22%" valign="top">A typical weight function. The peak value is typically 1 and the minimum zero, with compact support.   </td></tr>
</table>
<p>A weight function support need not be spherical, as illustrated above. Suitable weight functions can be constructed with supports comprised of ellipses, boxes, or arbitrary polygons or polyhedra. A smooth weight function used for particles generalizes the "top-hat" or unitary weight function used for meshes that has a value of 1 inside the cell and 0 outside. Meshes are a special case of particles. In fact, under certain conditions on the weight function, the LRE reproduces finite element nodal shape functions.</p>
<p>The centers of the weight function supports are typically located in two places. If on the target particles, the estimator is called "gather-form", if on the source particles, the estimator is called "scatter-form", illustrated below.</p>
<table style="width:100%">
<tr>
<td valign="top"><div class="image">
<img src="gather_form.png" alt="Gather" class="fullwidth"/>
</div>
 </td><td width="4%"></td><td valign="top"><div class="image">
<img src="scatter_form.png" alt="Scatter" class="fullwidth"/>
</div>
  </td></tr>
<tr>
<td width="22%" valign="top">Gather-form search. The centers of the weight function supports are located at the target particle centers. </td><td width="4%"></td><td width="22%" valign="top">Scatter-form search. The centers of the weight function supports are located at the source particle centers. The supports need not all have the same shape.  </td></tr>
</table>
<p>The weight function kernel and shape are specified by Portage::MeshFree::Weight::Kernel and Portage::MeshFree::Weight::Geometry.</p>
<p>Any sort of bounding performed, e.g. to partition among processors, needs to take into account the extent of the weight function supports. These are the search methods for particles:</p>
<ul>
<li><a class="el" href="classPortage_1_1SearchSimplePoints.html" title="A simple, crude search algorithm that does a quadratic-time search over a swarm of points...">Portage::SearchSimplePoints</a> - any-d quadratic time search over particle swarms</li>
<li><a class="el" href="classPortage_1_1SearchPointsByCells.html" title="A simple, crude search algorithm that does a linear-time search over a swarm of points. ">Portage::SearchPointsByCells</a> - any-d linear time search over particle swarms using a bounding box containing the particles and their extent based on smoothing lengths</li>
</ul>
<p>The weight function location is specified by Portage::MeshFree::WeightCenter. A set of input smoothing lengths determine the size of the weight function support.</p>
<h3>Accumulate</h3>
<p>Most meshfree methods make approximations by means of discrete kernel transforms, which involve summing data values times kernel values at various points. Even though the kernels are defined over the entire swarm, compact support means only a small number of particles typically have non-zero values. The set of such particles is analogous to the stencil used in a meshed method.</p>
<p>For LRE, discrete transforms of different powers of the particle coordinates are made (moments), assembled into a matrix, solved against a vector of moments and finally multiplied by the kernel function. This yields a set of weights for each neighboring particle data value, one for each derivative estimate. The concept for gather and scatter forms applied to the second moment of position is illustrated below.</p>
<table style="width:100%">
<tr>
<td valign="top"><div class="image">
<img src="gatherScheme.png" alt="GatherScheme" class="fullwidth"/>
</div>
 </td><td width="4%"></td><td valign="top"><div class="image">
<img src="scatterScheme.png" alt="ScatterScheme" class="fullwidth"/>
</div>
  </td></tr>
<tr>
<td width="22%" valign="top">Gather-form accumulate. The source data values (blue spikes) multiply the values of a given target kernel (in red) at the location of the spikes and are summed to the value associated with the given red dot. </td><td width="4%"></td><td width="22%" valign="top">Scatter-form accumulate. The source data values (blue spikes) multiply the values of the source kernels at the red dots (centers of the target particles) and are summed there.  </td></tr>
</table>
<p>The only available meshfree method for accumulate is:</p>
<ul>
<li>Portage::swarm::Accumulate - any-d accumulator that works with various weight function shapes, kernel functions, basis functions and estimator models.</li>
</ul>
<p>Developers may write their own Accumulate class.</p>
<h3>Estimate</h3>
<p>Given the list of source particles and their weighted contributions to a given target particle, along with source field data, this step actually populates the fields on the target particles. All of the heavy-lifting of the remap for particles has been done in the accumulate phase, such that this step results in a basic matrix vector multiply between the field data on source particles and the weights for the various orders of derivative.</p>
<p>The sole available Estimate method is:</p>
<ul>
<li>Portage::swarm::Estimate - use the output of Portage::Accumulate to estimate the target field data with varying degrees of accuracy.</li>
</ul>
<p>but developers are free to substitute a different one.</p>
<p><br />
</p>
<p>Note that while the meshfree interpolation can go to <em>very high order of accuracy</em> it is still <em>not strictly conservative</em> like the mesh-mesh remap. Also, meshfree remapping currently does not incorporate mechanisms for local or global bounds preservation in the interpolation. Consequently, users must be conscious of the fact that going to higher orders of interpolation carries the risk of bounds violation. Furthermore, particle remap is not currently sensitive to multi-material data fields. These difficulties will be addressed in future code releases.</p>
<h2>Coordinate Systems</h2>
<p><a class="el" href="namespacePortage.html">Portage</a> provides the tools to remap in different coordinate systems. Details are given in the coordinate_systems.pdf document.</p>
<p>The coordinates used by <a class="el" href="namespacePortage.html">Portage</a> are based on ISO 80000-2:2009, and are shown here:<br />
 </p><div class="image">
<img src="coordinates.png" alt="coordinates.png"/>
<div class="caption">
physics coordinates</div></div>
<p><br />
This is a public domain image from Wikimedia Commons and can be found at <a href="https://commons.wikimedia.org/wiki/File:Physics_Coordinates.png">https://commons.wikimedia.org/wiki/File:Physics_Coordinates.png.</a></p>
<table class="doxtable">
<tr>
<th>variable </th><th align="left">meaning  </th></tr>
<tr>
<td>x </td><td align="left">the first Cartesian coordinate </td></tr>
<tr>
<td>y </td><td align="left">the second Cartesian coordinate </td></tr>
<tr>
<td>z </td><td align="left">the third Cartesian coordinate </td></tr>
<tr>
<td>r </td><td align="left">the distance from the origin (spherical radius) </td></tr>
<tr>
<td>&rho; </td><td align="left">the distance from the z axis (cylindrical radius) </td></tr>
<tr>
<td>&phi; </td><td align="left">the azimuthal angle (around the z axis, starting at the positive x axis) </td></tr>
<tr>
<td>&theta; </td><td align="left">the angle of declination (descending from the positive z axis) </td></tr>
</table>
<p>The available coordinate systems are</p>
<ul>
<li><code>CartesianCoordinates&lt;3&gt;</code>: 3D Cartesian coordinates, (x,y,z); the "basic" right-handed 3D coordinates;</li>
<li><code>CartesianCoordinates&lt;2&gt;</code>: 2D Cartesian coordinates, (x,y); the "basic" 2D coordinates;</li>
<li><code>CartesianCoordinates&lt;1&gt;</code>: 1D Cartesian coordinates, (x); the "basic" 1D coordinates;</li>
<li><code>Cylindrical3DCoordinates</code>: 3D cylindrical coordinates, (&rho;, &phi;, z);</li>
<li><code>CylindricalPolarCoordinates</code>: 2D cylindrical polar coordinates, (&rho;, &phi;); the "usual" polar coordinates;</li>
<li><code>CylindricalAxisymmetricCoordinates</code>: 2D cylindrical axisymmetric coordinates, (&rho;,z); implicitly a 3D coordinate system, where the plane of the grid is rotated around the z axis (i.e., no variation with the azimuthal angle &phi;);</li>
<li><code>CylindricalRadialCoordinates</code>: 1D cylindrical radial coordinates, (&rho;); implicitly a 2D coordinate system, where quantities depend only on their 2D distance from the origin &rho;, not on the azimuthal angle &phi;;</li>
<li><code>Spherical3DCoordinates</code>: 3D spherical coordinates, (r,&theta;,&phi;);</li>
<li><code>SphericalRadialCoordinates</code>: 1D spherical radial coordinates, (r); implicitly a 3D coordinate system, where there is no variation with either the azimuthal angle &phi; or declination angle &theta;, but only the 3D distance from the origin r.</li>
</ul>
<p>Additional coordinate systems can be implemented, following the model of the existing coordinate systems.</p>
<p>It is currently assumed that both the target and source meshes are using the same coordinate system.</p>
<p>Not all components of <a class="el" href="namespacePortage.html">Portage</a> are available with non-Cartesian coordinate systems. Look for a template for the coordinate system to be certain that a given component of <a class="el" href="namespacePortage.html">Portage</a> is designed to work with non-Cartesian coordinate systems.</p>
<p><br />
</p>
<p>[1] Margolin, L.G. and Shashkov, M.J. "Second-order sign-preserving
  conservative interpolation (remapping) on general grids," Journal of Computational Physics, v 184, n 1, pp. 266-298, 2003.</p>
<p>[2] Dukowicz, J.K. and Kodis, J.W. "Accurate Conservative Remapping
  (Rezoning) for Arbitrary Lagrangian-Eulerian Computations," SIAM Journal on Scientific and Statistical Computing, Vol. 8, No. 3, pp. 305-321, 1987.</p>
<p>[3] Kucharik, M. and Shashkov, M.J. "Conservative Multi-Material Remap
for Staggered Multi-Material Arbitrary Lagrangian-Eulerian Methods," Journal of Computational Physics, v 258, pp. 268-304, 2014.</p>
<p>[4] Fogerty, S., Martineau, M., Garimella, R.V. and Robey, R.W. "A Comparative Study of Multi-Material Data Structures for Computational Physics Applications," Computers and Mathematics with Applications, 2018.</p>
<p>[5] Dilts, G.A. "Estimation of Integral Operators on Random Data," Los Alamos Technical Report, LA-UR-17-23408, Los Alamos National Laboratory, Los Alamos, NM 2017.</p>
<p>[6] Garimella, R.V. "A Simple Introduction to Moving Least Squares and
Local Regression Estimation," Los Alamos Technical Report, LA-UR-17-24975, Los Alamos National Laboratory, Los Alamos, NM 2017. </p>
</div></div><!-- contents -->
<!--
This file is part of the Ristra portage project.
Please see the license file at the root of this repository, or at:
    https://github.com/laristra/portage/blob/master/LICENSE
-->
<!-- HTML footer for doxygen 1.8.8-->
<!-- start footer part -->
</div>
</div>
</div>
</div>
</div>
<!--<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address> -->
<footer id="footer" class="footer">
  <div class="container">
    <div class="row test-muted">
      <div class="footer-row col-md-6">Copyright &copy; 2019
	<a href="http://lanl.gov"> Triad National Security, LLC</a>
	All Rights Reserved.
      </div>
      <div class="footer-row col-md-2">
	<a href="https://github.com/laristra/portage/blob/master/LICENSE">
	  BSD LICENSE
	</a>
      </div>
      <div class="footer-row col-md-2">
	LA-CC-16-084
      </div>
      <div class="footer-row col-md-1">
	<a href="mailto:portage@lanl.gov">
	  <i class="fa fa-envelope-o fa-2x"></i>
	</a>
      </div>
      <div class="footer-row col-md-1">
	<a href="https://github.com/laristra/portage">
	  <i class="fa fa-github fa-2x"></i>
	</a>
      </div>
    </div>
  </div>
</footer>
<script type="text/javascript" src="doxy-boot.js"></script>
</body>
</html>
