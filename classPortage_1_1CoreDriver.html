<!--
This file is part of the Ristra portage project.
Please see the license file at the root of this repository, or at:
    https://github.com/laristra/portage/blob/master/LICENSE
-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
    <meta http-equiv="X-UA-Compatible" content="IE=edge"/>
    <meta name="generator" content="Doxygen 1.8.13"/>
    <!-- For Mobile Devices -->
    <meta name="viewport" content="width=device-width, initial-scale=1"/>
    <!-- Font stuff -->
    <link href='//fonts.googleapis.com/css?family=Roboto+Slab' rel='stylesheet' type='text/css'/>
    <script src="//use.fontawesome.com/3dce4d8e65.js"></script>
    <!-- the default version jquery provided by doxygen is too old for bootstrap
	 but it also contains local modifications.  we have extracted those that
	 are needed so that we can use a newer jquery. -->
    <!-- <script type="text/javascript" src="//code.jquery.com/jquery-3.1.1.min.js"></script> -->
    <script
			  src="//code.jquery.com/jquery-3.3.1.min.js"
			  integrity="sha256-FgpCb/KJQlLNfOu91ta32o/NMZxltwRo8QtmkMRdAu8="
			  crossorigin="anonymous"></script>
      <!-- <script src="//code.jquery.com/jquery-3.3.1.min.js" integrity="sha384-q8i/X+965DzO0rT7abK41JStQIAqVgRVzpbzo5smXKp4YfRvH+8abtTE1Pi6jizo" crossorigin="anonymous"></script> -->
    <script type="text/javascript" src="smartmenu.js"></script>
    <title>portage: Portage::CoreDriver&lt; D, ONWHAT, SourceMesh, SourceState, TargetMesh, TargetState, InterfaceReconstructorType, Matpoly_Splitter, Matpoly_Clipper, CoordSys &gt; Class Template Reference</title>
    <link href="tabs.css" rel="stylesheet" type="text/css">
      <!-- this version is too old for bootstrap, but it includes modifications
	   from standard jquery
    <script type="text/javascript" src="jquery.js"></script>  -->
    <script type="text/javascript" src="dynsections.js"></script>
    <script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js"></script>
    <link href="doxygen.css" rel="stylesheet" type="text/css" />
    <link href="customdoxygen.css" rel="stylesheet" type="text/css"/>
    <link rel="stylesheet" href="//stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous">
<script src="//cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.7/umd/popper.min.js" integrity="sha384-UO2eT0CpHqdSJQ6hJty5KVphtPhzWj9WO1clHTMGa3JDZwrnQq4sF86dIHNDz0W1" crossorigin="anonymous"></script>
<script src="//stackpath.bootstrapcdn.com/bootstrap/4.3.1/js/bootstrap.min.js" integrity="sha384-JjSmVgyd0p3pXB1rRibZUAYoIIy6OrQ6VrjIEaFf/nJGzIxFDsf4x0xIM+B07jRM" crossorigin="anonymous"></script>
    <!-- <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css"/> -->
    <!-- <script src="//maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js"></script> -->
  </head>
  <body>
    <nav class="navbar navbar-default" role="navigation">
      <div class="container">
        <div class="navbar-header">
          <img src="Portage-logo-small.png" alt="portage">
        </div>
      </div>
    </nav>
    <div id="top"><!-- do not remove this div, it is closed by doxygen! -->
      <div class="content" id="content">
        <div class="container">
          <div class="row">
            <div class="col-sm-12 panel " style="padding-bottom: 15px;">
              <div style="margin-bottom: 15px;">
      		<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',false,false,'search.php','Search');
});
</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacePortage.html">Portage</a></li><li class="navelem"><a class="el" href="classPortage_1_1CoreDriver.html">CoreDriver</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classPortage_1_1CoreDriver-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Portage::CoreDriver&lt; D, ONWHAT, SourceMesh, SourceState, TargetMesh, TargetState, InterfaceReconstructorType, Matpoly_Splitter, Matpoly_Clipper, CoordSys &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><a class="el" href="classPortage_1_1CoreDriver.html" title="CoreDriver - Core driver that remaps fields on a particular Entity_kind (ONWHAT) like CELL or NODE...">CoreDriver</a> - Core driver that remaps fields on a particular Entity_kind (ONWHAT) like CELL or NODE.  
 <a href="classPortage_1_1CoreDriver.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="coredriver_8h_source.html">coredriver.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for Portage::CoreDriver&lt; D, ONWHAT, SourceMesh, SourceState, TargetMesh, TargetState, InterfaceReconstructorType, Matpoly_Splitter, Matpoly_Clipper, CoordSys &gt;:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classPortage_1_1CoreDriver.png" usemap="#Portage::CoreDriver_3C_20D_2C_20ONWHAT_2C_20SourceMesh_2C_20SourceState_2C_20TargetMesh_2C_20TargetState_2C_20InterfaceReconstructorType_2C_20Matpoly_5FSplitter_2C_20Matpoly_5FClipper_2C_20CoordSys_20_3E_map" alt=""/>
  <map id="Portage::CoreDriver_3C_20D_2C_20ONWHAT_2C_20SourceMesh_2C_20SourceState_2C_20TargetMesh_2C_20TargetState_2C_20InterfaceReconstructorType_2C_20Matpoly_5FSplitter_2C_20Matpoly_5FClipper_2C_20CoordSys_20_3E_map" name="Portage::CoreDriver_3C_20D_2C_20ONWHAT_2C_20SourceMesh_2C_20SourceState_2C_20TargetMesh_2C_20TargetState_2C_20InterfaceReconstructorType_2C_20Matpoly_5FSplitter_2C_20Matpoly_5FClipper_2C_20CoordSys_20_3E_map">
<area href="classPortage_1_1CoreDriverBase.html" title="CoreDriverBase - Base class for core driver that is agnostic to the Entity_kind. " alt="Portage::CoreDriverBase&lt; D, SourceMesh, SourceState, TargetMesh, TargetState, InterfaceReconstructorType, Matpoly_Splitter, Matpoly_Clipper, CoordSys &gt;" shape="rect" coords="0,0,964,24"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a69dbb2aa683ebc1eaa17c59ea601c190"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPortage_1_1CoreDriver.html#a69dbb2aa683ebc1eaa17c59ea601c190">CoreDriver</a> (SourceMesh const &amp;source_mesh, SourceState const &amp;source_state, TargetMesh const &amp;target_mesh, TargetState &amp;target_state, Wonton::Executor_type const *executor=nullptr)</td></tr>
<tr class="memdesc:a69dbb2aa683ebc1eaa17c59ea601c190"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor for the CORE remap driver.  <a href="#a69dbb2aa683ebc1eaa17c59ea601c190">More...</a><br /></td></tr>
<tr class="separator:a69dbb2aa683ebc1eaa17c59ea601c190"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac44f144a0a6f3495fcf3f51ed68e68e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPortage_1_1CoreDriver.html#aac44f144a0a6f3495fcf3f51ed68e68e">CoreDriver</a> (const <a class="el" href="classPortage_1_1CoreDriver.html">CoreDriver</a> &amp;)=delete</td></tr>
<tr class="memdesc:aac44f144a0a6f3495fcf3f51ed68e68e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor (disabled)  <a href="#aac44f144a0a6f3495fcf3f51ed68e68e">More...</a><br /></td></tr>
<tr class="separator:aac44f144a0a6f3495fcf3f51ed68e68e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd29bbaa2f9ac5530d8896bb89935e23"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPortage_1_1CoreDriver.html">CoreDriver</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPortage_1_1CoreDriver.html#abd29bbaa2f9ac5530d8896bb89935e23">operator=</a> (const <a class="el" href="classPortage_1_1CoreDriver.html">CoreDriver</a> &amp;)=delete</td></tr>
<tr class="memdesc:abd29bbaa2f9ac5530d8896bb89935e23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment operator (disabled)  <a href="#abd29bbaa2f9ac5530d8896bb89935e23">More...</a><br /></td></tr>
<tr class="separator:abd29bbaa2f9ac5530d8896bb89935e23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87c43d90b01f4c19cb2aa275eef82c51"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPortage_1_1CoreDriver.html#a87c43d90b01f4c19cb2aa275eef82c51">~CoreDriver</a> ()=default</td></tr>
<tr class="memdesc:a87c43d90b01f4c19cb2aa275eef82c51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor.  <a href="#a87c43d90b01f4c19cb2aa275eef82c51">More...</a><br /></td></tr>
<tr class="separator:a87c43d90b01f4c19cb2aa275eef82c51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc5a4eb4f0a9bf447a4441efa9504632"><td class="memItemLeft" align="right" valign="top">Entity_kind&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPortage_1_1CoreDriver.html#acc5a4eb4f0a9bf447a4441efa9504632">onwhat</a> ()</td></tr>
<tr class="memdesc:acc5a4eb4f0a9bf447a4441efa9504632"><td class="mdescLeft">&#160;</td><td class="mdescRight">What entity kind is this defined on?  <a href="#acc5a4eb4f0a9bf447a4441efa9504632">More...</a><br /></td></tr>
<tr class="separator:acc5a4eb4f0a9bf447a4441efa9504632"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adaa4df6ae5913f1f0abe8d24d6a0ef4d"><td class="memTemplParams" colspan="2">template&lt;template&lt; int, Entity_kind, class, class &gt; class Search&gt; </td></tr>
<tr class="memitem:adaa4df6ae5913f1f0abe8d24d6a0ef4d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacePortage.html#ad86a06a9372f05948709ca73e058981d">Portage::vector</a>&lt; std::vector&lt; int &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classPortage_1_1CoreDriver.html#adaa4df6ae5913f1f0abe8d24d6a0ef4d">search</a> ()</td></tr>
<tr class="separator:adaa4df6ae5913f1f0abe8d24d6a0ef4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd59ea61f292ed7cfdb5bc2f883ac2c8"><td class="memTemplParams" colspan="2">template&lt;template&lt; Entity_kind, class, class, class, template&lt; class, int, class, class &gt; class, class, class &gt; class Intersect&gt; </td></tr>
<tr class="memitem:afd59ea61f292ed7cfdb5bc2f883ac2c8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacePortage.html#ad86a06a9372f05948709ca73e058981d">Portage::vector</a>&lt; std::vector&lt; Portage::Weights_t &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classPortage_1_1CoreDriver.html#afd59ea61f292ed7cfdb5bc2f883ac2c8">intersect_meshes</a> (<a class="el" href="namespacePortage.html#ad86a06a9372f05948709ca73e058981d">Portage::vector</a>&lt; std::vector&lt; int &gt;&gt; const &amp;candidates)</td></tr>
<tr class="separator:afd59ea61f292ed7cfdb5bc2f883ac2c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade0e76d3da30898b787e3072db0556e3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPortage_1_1CoreDriver.html#ade0e76d3da30898b787e3072db0556e3">set_num_tols</a> (const double min_absolute_distance, const double min_absolute_volume)</td></tr>
<tr class="memdesc:ade0e76d3da30898b787e3072db0556e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set core numerical tolerances.  <a href="#ade0e76d3da30898b787e3072db0556e3">More...</a><br /></td></tr>
<tr class="separator:ade0e76d3da30898b787e3072db0556e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb9ea0ac90f4aa09af3b83c714b870c9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPortage_1_1CoreDriver.html#adb9ea0ac90f4aa09af3b83c714b870c9">set_num_tols</a> (const <a class="el" href="structPortage_1_1NumericTolerances__t.html">NumericTolerances_t</a> &amp;num_tols)</td></tr>
<tr class="memdesc:adb9ea0ac90f4aa09af3b83c714b870c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set all numerical tolerances.  <a href="#adb9ea0ac90f4aa09af3b83c714b870c9">More...</a><br /></td></tr>
<tr class="separator:adb9ea0ac90f4aa09af3b83c714b870c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2748460fda1bf11f962f33a5756b0627"><td class="memTemplParams" colspan="2">template&lt;template&lt; Entity_kind, class, class, class, template&lt; class, int, class, class &gt; class, class, class &gt; class Intersect&gt; </td></tr>
<tr class="memitem:a2748460fda1bf11f962f33a5756b0627"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="namespacePortage.html#ad86a06a9372f05948709ca73e058981d">Portage::vector</a>&lt; std::vector&lt; Weights_t &gt; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classPortage_1_1CoreDriver.html#a2748460fda1bf11f962f33a5756b0627">intersect_materials</a> (<a class="el" href="namespacePortage.html#ad86a06a9372f05948709ca73e058981d">Portage::vector</a>&lt; std::vector&lt; int &gt;&gt; const &amp;candidates)</td></tr>
<tr class="separator:a2748460fda1bf11f962f33a5756b0627"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add913253c13d7646ad1a6331b27b816b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacePortage.html#ad86a06a9372f05948709ca73e058981d">Portage::vector</a>&lt; Vector&lt; D &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPortage_1_1CoreDriver.html#add913253c13d7646ad1a6331b27b816b">compute_source_gradient</a> (std::string const field_name, <a class="el" href="namespacePortage.html#a4cb59edee64edb5a23427c8cb2fb5be6">Limiter_type</a> limiter_type=<a class="el" href="namespacePortage.html#a4cb59edee64edb5a23427c8cb2fb5be6a129ce73da39e28f090a4963952638f0f">NOLIMITER</a>, <a class="el" href="namespacePortage.html#a749d03d65d45c5468ee09f871868118f">Boundary_Limiter_type</a> boundary_limiter_type=<a class="el" href="namespacePortage.html#a749d03d65d45c5468ee09f871868118fa7df68da5020422a2b128d16d534e07d4">BND_NOLIMITER</a>, int material_id=0, const <a class="el" href="classPortage_1_1Part.html">Part</a>&lt; SourceMesh, SourceState &gt; *source_part=nullptr) const</td></tr>
<tr class="memdesc:add913253c13d7646ad1a6331b27b816b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the gradient field of the given variable on source mesh.  <a href="#add913253c13d7646ad1a6331b27b816b">More...</a><br /></td></tr>
<tr class="separator:add913253c13d7646ad1a6331b27b816b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3a4b73c1e2724321af8ee2ab81f6395"><td class="memTemplParams" colspan="2">template&lt;typename T  = double, template&lt; int, Entity_kind, class, class, class, class, class, template&lt; class, int, class, class &gt; class, class, class, class &gt; class Interpolate&gt; </td></tr>
<tr class="memitem:ac3a4b73c1e2724321af8ee2ab81f6395"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classPortage_1_1CoreDriver.html#ac3a4b73c1e2724321af8ee2ab81f6395">interpolate_mesh_var</a> (std::string srcvarname, std::string trgvarname, <a class="el" href="namespacePortage.html#ad86a06a9372f05948709ca73e058981d">Portage::vector</a>&lt; std::vector&lt; Weights_t &gt;&gt; const &amp;sources_and_weights, <a class="el" href="namespacePortage.html#ad86a06a9372f05948709ca73e058981d">Portage::vector</a>&lt; Vector&lt; D &gt;&gt; *gradients=nullptr)</td></tr>
<tr class="memdesc:ac3a4b73c1e2724321af8ee2ab81f6395"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interpolate mesh variable.  <a href="#ac3a4b73c1e2724321af8ee2ab81f6395">More...</a><br /></td></tr>
<tr class="separator:ac3a4b73c1e2724321af8ee2ab81f6395"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e0b38d71f560f23ea57c7b7baaad4c1"><td class="memTemplParams" colspan="2">template&lt;typename T  = double, template&lt; int, Entity_kind, class, class, class, class, class, template&lt; class, int, class, class &gt; class, class, class, class &gt; class Interpolate, Entity_kind ONWHAT1 = ONWHAT, typename  = typename std::enable_if&lt;ONWHAT1 == CELL&gt;::type&gt; </td></tr>
<tr class="memitem:a2e0b38d71f560f23ea57c7b7baaad4c1"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classPortage_1_1CoreDriver.html#a2e0b38d71f560f23ea57c7b7baaad4c1">interpolate_mesh_var</a> (std::string srcvarname, std::string trgvarname, <a class="el" href="namespacePortage.html#ad86a06a9372f05948709ca73e058981d">Portage::vector</a>&lt; std::vector&lt; Weights_t &gt;&gt; const &amp;sources_and_weights, const <a class="el" href="classPortage_1_1PartPair.html">PartPair</a>&lt; D, SourceMesh, SourceState, TargetMesh, TargetState &gt; *partition, <a class="el" href="namespacePortage.html#ad86a06a9372f05948709ca73e058981d">Portage::vector</a>&lt; Vector&lt; D &gt;&gt; *gradients=nullptr)</td></tr>
<tr class="memdesc:a2e0b38d71f560f23ea57c7b7baaad4c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interpolate mesh variable from source part to target part.  <a href="#a2e0b38d71f560f23ea57c7b7baaad4c1">More...</a><br /></td></tr>
<tr class="separator:a2e0b38d71f560f23ea57c7b7baaad4c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43bbaadd288f7637b5cd8d2fc4cd1f08"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPortage_1_1CoreDriver.html#a43bbaadd288f7637b5cd8d2fc4cd1f08">check_mismatch</a> (<a class="el" href="namespacePortage.html#ad86a06a9372f05948709ca73e058981d">Portage::vector</a>&lt; std::vector&lt; Weights_t &gt;&gt; const &amp;source_weights)</td></tr>
<tr class="separator:a43bbaadd288f7637b5cd8d2fc4cd1f08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44a5fd5d37ea0372e26a8838d90f0506"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPortage_1_1CoreDriver.html#a44a5fd5d37ea0372e26a8838d90f0506">has_mismatch</a> ()</td></tr>
<tr class="separator:a44a5fd5d37ea0372e26a8838d90f0506"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9e74e229b6c432fc6ddf18d3accfbb1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPortage_1_1CoreDriver.html#af9e74e229b6c432fc6ddf18d3accfbb1">fix_mismatch</a> (std::string const &amp;src_var_name, std::string const &amp;trg_var_name, double global_lower_bound=-std::numeric_limits&lt; double &gt;::max(), double global_upper_bound=std::numeric_limits&lt; double &gt;::max(), double conservation_tol=1e2 *std::numeric_limits&lt; double &gt;::epsilon(), int maxiter=5, Partial_fixup_type partial_fixup_type=Partial_fixup_type::SHIFTED_CONSERVATIVE, Empty_fixup_type empty_fixup_type=Empty_fixup_type::EXTRAPOLATE)</td></tr>
<tr class="memdesc:af9e74e229b6c432fc6ddf18d3accfbb1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Repair the remapped field to account for boundary mismatch.  <a href="#af9e74e229b6c432fc6ddf18d3accfbb1">More...</a><br /></td></tr>
<tr class="separator:af9e74e229b6c432fc6ddf18d3accfbb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classPortage_1_1CoreDriverBase"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classPortage_1_1CoreDriverBase')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classPortage_1_1CoreDriverBase.html">Portage::CoreDriverBase&lt; D, SourceMesh, SourceState, TargetMesh, TargetState, InterfaceReconstructorType, Matpoly_Splitter, Matpoly_Clipper, CoordSys &gt;</a></td></tr>
<tr class="memitem:a8c9c40a763f781ecef214dcf8faf1ff0 inherit pub_methods_classPortage_1_1CoreDriverBase"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPortage_1_1CoreDriverBase.html#a8c9c40a763f781ecef214dcf8faf1ff0">CoreDriverBase</a> ()=default</td></tr>
<tr class="separator:a8c9c40a763f781ecef214dcf8faf1ff0 inherit pub_methods_classPortage_1_1CoreDriverBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad07756697c45b7226c07c32fe6368263 inherit pub_methods_classPortage_1_1CoreDriverBase"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPortage_1_1CoreDriverBase.html#ad07756697c45b7226c07c32fe6368263">~CoreDriverBase</a> ()=default</td></tr>
<tr class="separator:ad07756697c45b7226c07c32fe6368263 inherit pub_methods_classPortage_1_1CoreDriverBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a491cf23f88a104e5864d8a9ee06be173 inherit pub_methods_classPortage_1_1CoreDriverBase"><td class="memTemplParams" colspan="2">template&lt;Entity_kind ONWHAT, template&lt; int, Entity_kind, class, class &gt; class Search&gt; </td></tr>
<tr class="memitem:a491cf23f88a104e5864d8a9ee06be173 inherit pub_methods_classPortage_1_1CoreDriverBase"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacePortage.html#ad86a06a9372f05948709ca73e058981d">Portage::vector</a>&lt; std::vector&lt; int &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classPortage_1_1CoreDriverBase.html#a491cf23f88a104e5864d8a9ee06be173">search</a> ()</td></tr>
<tr class="memdesc:a491cf23f88a104e5864d8a9ee06be173 inherit pub_methods_classPortage_1_1CoreDriverBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">search for candidate source entities whose control volumes (cells, dual cells) overlap the control volumes of target cells  <a href="classPortage_1_1CoreDriverBase.html#a491cf23f88a104e5864d8a9ee06be173">More...</a><br /></td></tr>
<tr class="separator:a491cf23f88a104e5864d8a9ee06be173 inherit pub_methods_classPortage_1_1CoreDriverBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b430e22b998a7ccaea108c57170c554 inherit pub_methods_classPortage_1_1CoreDriverBase"><td class="memTemplParams" colspan="2">template&lt;Entity_kind ONWHAT, template&lt; Entity_kind, class, class, class, template&lt; class, int, class, class &gt; class, class, class &gt; class Intersect&gt; </td></tr>
<tr class="memitem:a8b430e22b998a7ccaea108c57170c554 inherit pub_methods_classPortage_1_1CoreDriverBase"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacePortage.html#ad86a06a9372f05948709ca73e058981d">Portage::vector</a>&lt; std::vector&lt; Portage::Weights_t &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classPortage_1_1CoreDriverBase.html#a8b430e22b998a7ccaea108c57170c554">intersect_meshes</a> (<a class="el" href="namespacePortage.html#ad86a06a9372f05948709ca73e058981d">Portage::vector</a>&lt; std::vector&lt; int &gt;&gt; const &amp;intersection_candidates)</td></tr>
<tr class="memdesc:a8b430e22b998a7ccaea108c57170c554 inherit pub_methods_classPortage_1_1CoreDriverBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">intersect target entities with candidate source entities  <a href="classPortage_1_1CoreDriverBase.html#a8b430e22b998a7ccaea108c57170c554">More...</a><br /></td></tr>
<tr class="separator:a8b430e22b998a7ccaea108c57170c554 inherit pub_methods_classPortage_1_1CoreDriverBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d0f90e7a8e150281d40b6897818ca4a inherit pub_methods_classPortage_1_1CoreDriverBase"><td class="memTemplParams" colspan="2">template&lt;template&lt; Entity_kind, class, class, class, template&lt; class, int, class, class &gt; class, class, class &gt; class Intersect&gt; </td></tr>
<tr class="memitem:a4d0f90e7a8e150281d40b6897818ca4a inherit pub_methods_classPortage_1_1CoreDriverBase"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="namespacePortage.html#ad86a06a9372f05948709ca73e058981d">Portage::vector</a>&lt; std::vector&lt; Portage::Weights_t &gt; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classPortage_1_1CoreDriverBase.html#a4d0f90e7a8e150281d40b6897818ca4a">intersect_materials</a> (<a class="el" href="namespacePortage.html#ad86a06a9372f05948709ca73e058981d">Portage::vector</a>&lt; std::vector&lt; int &gt;&gt; const &amp;intersection_candidates)</td></tr>
<tr class="separator:a4d0f90e7a8e150281d40b6897818ca4a inherit pub_methods_classPortage_1_1CoreDriverBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1dc06c23246f6884707091291c22633 inherit pub_methods_classPortage_1_1CoreDriverBase"><td class="memTemplParams" colspan="2">template&lt;Entity_kind ONWHAT&gt; </td></tr>
<tr class="memitem:ae1dc06c23246f6884707091291c22633 inherit pub_methods_classPortage_1_1CoreDriverBase"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacePortage.html#ad86a06a9372f05948709ca73e058981d">Portage::vector</a>&lt; Vector&lt; D &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classPortage_1_1CoreDriverBase.html#ae1dc06c23246f6884707091291c22633">compute_source_gradient</a> (std::string const field_name, <a class="el" href="namespacePortage.html#a4cb59edee64edb5a23427c8cb2fb5be6">Limiter_type</a> limiter_type=<a class="el" href="namespacePortage.html#a4cb59edee64edb5a23427c8cb2fb5be6a129ce73da39e28f090a4963952638f0f">NOLIMITER</a>, <a class="el" href="namespacePortage.html#a749d03d65d45c5468ee09f871868118f">Boundary_Limiter_type</a> boundary_limiter_type=<a class="el" href="namespacePortage.html#a749d03d65d45c5468ee09f871868118fa7df68da5020422a2b128d16d534e07d4">BND_NOLIMITER</a>, int material_id=0, const <a class="el" href="classPortage_1_1Part.html">Part</a>&lt; SourceMesh, SourceState &gt; *source_part=nullptr)</td></tr>
<tr class="memdesc:ae1dc06c23246f6884707091291c22633 inherit pub_methods_classPortage_1_1CoreDriverBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the gradient field of the given variable on source mesh.  <a href="classPortage_1_1CoreDriverBase.html#ae1dc06c23246f6884707091291c22633">More...</a><br /></td></tr>
<tr class="separator:ae1dc06c23246f6884707091291c22633 inherit pub_methods_classPortage_1_1CoreDriverBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcab4aae4e80d7074b8c59a5ffe991e2 inherit pub_methods_classPortage_1_1CoreDriverBase"><td class="memTemplParams" colspan="2">template&lt;typename T  = double, Entity_kind ONWHAT, template&lt; int, Entity_kind, class, class, class, class, class, template&lt; class, int, class, class &gt; class, class, class, class &gt; class Interpolate&gt; </td></tr>
<tr class="memitem:adcab4aae4e80d7074b8c59a5ffe991e2 inherit pub_methods_classPortage_1_1CoreDriverBase"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classPortage_1_1CoreDriverBase.html#adcab4aae4e80d7074b8c59a5ffe991e2">interpolate_mesh_var</a> (std::string srcvarname, std::string trgvarname, <a class="el" href="namespacePortage.html#ad86a06a9372f05948709ca73e058981d">Portage::vector</a>&lt; std::vector&lt; Weights_t &gt;&gt; const &amp;sources_and_weights, <a class="el" href="namespacePortage.html#ad86a06a9372f05948709ca73e058981d">Portage::vector</a>&lt; Vector&lt; D &gt;&gt; *gradients=nullptr)</td></tr>
<tr class="separator:adcab4aae4e80d7074b8c59a5ffe991e2 inherit pub_methods_classPortage_1_1CoreDriverBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38c51344d9e177dc16a9f0d032cc0641 inherit pub_methods_classPortage_1_1CoreDriverBase"><td class="memTemplParams" colspan="2">template&lt;typename T  = double, Entity_kind ONWHAT, template&lt; int, Entity_kind, class, class, class, class, class, template&lt; class, int, class, class &gt; class, class, class, class &gt; class Interpolate&gt; </td></tr>
<tr class="memitem:a38c51344d9e177dc16a9f0d032cc0641 inherit pub_methods_classPortage_1_1CoreDriverBase"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; ONWHAT==CELL, void &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classPortage_1_1CoreDriverBase.html#a38c51344d9e177dc16a9f0d032cc0641">interpolate_mesh_var</a> (std::string srcvarname, std::string trgvarname, <a class="el" href="namespacePortage.html#ad86a06a9372f05948709ca73e058981d">Portage::vector</a>&lt; std::vector&lt; Weights_t &gt;&gt; const &amp;sources_and_weights, const <a class="el" href="classPortage_1_1PartPair.html">PartPair</a>&lt; D, SourceMesh, SourceState, TargetMesh, TargetState &gt; *parts_pair, <a class="el" href="namespacePortage.html#ad86a06a9372f05948709ca73e058981d">Portage::vector</a>&lt; Vector&lt; D &gt;&gt; *gradients=nullptr)</td></tr>
<tr class="separator:a38c51344d9e177dc16a9f0d032cc0641 inherit pub_methods_classPortage_1_1CoreDriverBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a388404791a902f61628ca55599434e6e inherit pub_methods_classPortage_1_1CoreDriverBase"><td class="memTemplParams" colspan="2">template&lt;typename T  = double, template&lt; int, Entity_kind, class, class, class, class, class, template&lt; class, int, class, class &gt; class, class, class, class &gt; class Interpolate&gt; </td></tr>
<tr class="memitem:a388404791a902f61628ca55599434e6e inherit pub_methods_classPortage_1_1CoreDriverBase"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classPortage_1_1CoreDriverBase.html#a388404791a902f61628ca55599434e6e">interpolate_mat_var</a> (std::string srcvarname, std::string trgvarname, std::vector&lt; <a class="el" href="namespacePortage.html#ad86a06a9372f05948709ca73e058981d">Portage::vector</a>&lt; std::vector&lt; Weights_t &gt;&gt;&gt; const &amp;sources_and_weights_by_mat, std::vector&lt; <a class="el" href="namespacePortage.html#ad86a06a9372f05948709ca73e058981d">Portage::vector</a>&lt; Vector&lt; D &gt;&gt;&gt; *gradients=nullptr)</td></tr>
<tr class="separator:a388404791a902f61628ca55599434e6e inherit pub_methods_classPortage_1_1CoreDriverBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa221463a44f840bb19c806f557076e47 inherit pub_methods_classPortage_1_1CoreDriverBase"><td class="memTemplParams" colspan="2">template&lt;Entity_kind ONWHAT&gt; </td></tr>
<tr class="memitem:aa221463a44f840bb19c806f557076e47 inherit pub_methods_classPortage_1_1CoreDriverBase"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classPortage_1_1CoreDriverBase.html#aa221463a44f840bb19c806f557076e47">check_mismatch</a> (<a class="el" href="namespacePortage.html#ad86a06a9372f05948709ca73e058981d">Portage::vector</a>&lt; std::vector&lt; Weights_t &gt;&gt; const &amp;source_weights)</td></tr>
<tr class="memdesc:aa221463a44f840bb19c806f557076e47 inherit pub_methods_classPortage_1_1CoreDriverBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if meshes are mismatched (don't cover identical portions of space)  <a href="classPortage_1_1CoreDriverBase.html#aa221463a44f840bb19c806f557076e47">More...</a><br /></td></tr>
<tr class="separator:aa221463a44f840bb19c806f557076e47 inherit pub_methods_classPortage_1_1CoreDriverBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85f0ea15fd30eb1d0b4b22e2efbfb981 inherit pub_methods_classPortage_1_1CoreDriverBase"><td class="memTemplParams" colspan="2">template&lt;Entity_kind ONWHAT&gt; </td></tr>
<tr class="memitem:a85f0ea15fd30eb1d0b4b22e2efbfb981 inherit pub_methods_classPortage_1_1CoreDriverBase"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classPortage_1_1CoreDriverBase.html#a85f0ea15fd30eb1d0b4b22e2efbfb981">has_mismatch</a> ()</td></tr>
<tr class="memdesc:a85f0ea15fd30eb1d0b4b22e2efbfb981 inherit pub_methods_classPortage_1_1CoreDriverBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return if meshes are mismatched (check_mismatch must already have been called)  <a href="classPortage_1_1CoreDriverBase.html#a85f0ea15fd30eb1d0b4b22e2efbfb981">More...</a><br /></td></tr>
<tr class="separator:a85f0ea15fd30eb1d0b4b22e2efbfb981 inherit pub_methods_classPortage_1_1CoreDriverBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3b5e78e31fd2ea9e60a20b8d55e09e5 inherit pub_methods_classPortage_1_1CoreDriverBase"><td class="memTemplParams" colspan="2">template&lt;Entity_kind ONWHAT&gt; </td></tr>
<tr class="memitem:ab3b5e78e31fd2ea9e60a20b8d55e09e5 inherit pub_methods_classPortage_1_1CoreDriverBase"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classPortage_1_1CoreDriverBase.html#ab3b5e78e31fd2ea9e60a20b8d55e09e5">fix_mismatch</a> (std::string const &amp;src_var_name, std::string const &amp;trg_var_name, double global_lower_bound=-std::numeric_limits&lt; double &gt;::max(), double global_upper_bound=std::numeric_limits&lt; double &gt;::max(), double conservation_tol=1e2 *std::numeric_limits&lt; double &gt;::epsilon(), int maxiter=5, Partial_fixup_type partial_fixup_type=Partial_fixup_type::SHIFTED_CONSERVATIVE, Empty_fixup_type empty_fixup_type=Empty_fixup_type::EXTRAPOLATE)</td></tr>
<tr class="memdesc:ab3b5e78e31fd2ea9e60a20b8d55e09e5 inherit pub_methods_classPortage_1_1CoreDriverBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return if meshes are mismatched (check_mismatch must already have been called)  <a href="classPortage_1_1CoreDriverBase.html#ab3b5e78e31fd2ea9e60a20b8d55e09e5">More...</a><br /></td></tr>
<tr class="separator:ab3b5e78e31fd2ea9e60a20b8d55e09e5 inherit pub_methods_classPortage_1_1CoreDriverBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5ebe92943c3634647d281e089b7820b inherit pub_methods_classPortage_1_1CoreDriverBase"><td class="memTemplParams" colspan="2">template&lt;Entity_kind ONWHAT&gt; </td></tr>
<tr class="memitem:ad5ebe92943c3634647d281e089b7820b inherit pub_methods_classPortage_1_1CoreDriverBase"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classPortage_1_1CoreDriverBase.html#ad5ebe92943c3634647d281e089b7820b">set_num_tols</a> (const double min_absolute_distance, const double min_absolute_volume)</td></tr>
<tr class="memdesc:ad5ebe92943c3634647d281e089b7820b inherit pub_methods_classPortage_1_1CoreDriverBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set numerical tolerances for small distances and volumes.  <a href="classPortage_1_1CoreDriverBase.html#ad5ebe92943c3634647d281e089b7820b">More...</a><br /></td></tr>
<tr class="separator:ad5ebe92943c3634647d281e089b7820b inherit pub_methods_classPortage_1_1CoreDriverBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a640f87fb9dc94b02cff5fd254380d455 inherit pub_methods_classPortage_1_1CoreDriverBase"><td class="memTemplParams" colspan="2">template&lt;Entity_kind ONWHAT&gt; </td></tr>
<tr class="memitem:a640f87fb9dc94b02cff5fd254380d455 inherit pub_methods_classPortage_1_1CoreDriverBase"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classPortage_1_1CoreDriverBase.html#a640f87fb9dc94b02cff5fd254380d455">set_num_tols</a> (const <a class="el" href="structPortage_1_1NumericTolerances__t.html">NumericTolerances_t</a> &amp;num_tols)</td></tr>
<tr class="memdesc:a640f87fb9dc94b02cff5fd254380d455 inherit pub_methods_classPortage_1_1CoreDriverBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set numerical tolerances for small volumes, distances, etc.  <a href="classPortage_1_1CoreDriverBase.html#a640f87fb9dc94b02cff5fd254380d455">More...</a><br /></td></tr>
<tr class="separator:a640f87fb9dc94b02cff5fd254380d455 inherit pub_methods_classPortage_1_1CoreDriverBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;int D, Entity_kind ONWHAT, class SourceMesh, class SourceState, class TargetMesh = SourceMesh, class TargetState = SourceState, template&lt; class, int, class, class &gt; class InterfaceReconstructorType = DummyInterfaceReconstructor, class Matpoly_Splitter = void, class Matpoly_Clipper = void, class CoordSys = Wonton::DefaultCoordSys&gt;<br />
class Portage::CoreDriver&lt; D, ONWHAT, SourceMesh, SourceState, TargetMesh, TargetState, InterfaceReconstructorType, Matpoly_Splitter, Matpoly_Clipper, CoordSys &gt;</h3>

<p><a class="el" href="classPortage_1_1CoreDriver.html" title="CoreDriver - Core driver that remaps fields on a particular Entity_kind (ONWHAT) like CELL or NODE...">CoreDriver</a> - Core driver that remaps fields on a particular Entity_kind (ONWHAT) like CELL or NODE. </p>
<p>NOTE: THIS CLASS ASSUMES THAT ALL SOURCE CELLS OVERLAPPING ANY TARGET CELL ARE AVAILABLE ON THIS PROCESSOR. IT DOES NOT HAVE TO FETCH THE DATA FROM ANYWHERE</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ONWHAT</td><td>On what kind of entity are we doing the remap</td></tr>
    <tr><td class="paramname">SourceMesh</td><td>A lightweight wrapper to a specific input mesh implementation that provides certain functionality.</td></tr>
    <tr><td class="paramname">SourceState</td><td>A lightweight wrapper to a specific input state manager implementation that provides certain functionality.</td></tr>
    <tr><td class="paramname">TargetMesh</td><td>A lightweight wrapper to a specific output mesh implementation that provides certain functionality.</td></tr>
    <tr><td class="paramname">TargetState</td><td>A lightweight wrapper to a specific output state manager implementation that provides certain functionality.</td></tr>
    <tr><td class="paramname">InterfaceReconstructorType</td><td>The Interface Reconstructor class we will instantiate</td></tr>
    <tr><td class="paramname">Matpoly_Splitter</td><td>Class to split a polyhedron into two pieces</td></tr>
    <tr><td class="paramname">Matpoly_Clipper</td><td>Class to clip a polyhedron with a plane and return the piece behind the plane</td></tr>
  </table>
  </dd>
</dl>
<p>CoordSys Coordinate system being used for calculations </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a69dbb2aa683ebc1eaa17c59ea601c190"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69dbb2aa683ebc1eaa17c59ea601c190">&#9670;&nbsp;</a></span>CoreDriver() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int D, Entity_kind ONWHAT, class SourceMesh , class SourceState , class TargetMesh  = SourceMesh, class TargetState  = SourceState, template&lt; class, int, class, class &gt; class InterfaceReconstructorType = DummyInterfaceReconstructor, class Matpoly_Splitter  = void, class Matpoly_Clipper  = void, class CoordSys  = Wonton::DefaultCoordSys&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPortage_1_1CoreDriver.html">Portage::CoreDriver</a>&lt; D, ONWHAT, SourceMesh, SourceState, TargetMesh, TargetState, InterfaceReconstructorType, Matpoly_Splitter, Matpoly_Clipper, CoordSys &gt;::<a class="el" href="classPortage_1_1CoreDriver.html">CoreDriver</a> </td>
          <td>(</td>
          <td class="paramtype">SourceMesh const &amp;&#160;</td>
          <td class="paramname"><em>source_mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SourceState const &amp;&#160;</td>
          <td class="paramname"><em>source_state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TargetMesh const &amp;&#160;</td>
          <td class="paramname"><em>target_mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TargetState &amp;&#160;</td>
          <td class="paramname"><em>target_state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Wonton::Executor_type const *&#160;</td>
          <td class="paramname"><em>executor</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor for the CORE remap driver. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sourceMesh</td><td>A <code>wrapper</code> to the source mesh (may be native or redistributed source).</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sourceState</td><td>A <code>wrapper</code> for the data that lives on the source mesh</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">targetMesh</td><td>A <code>TargetMesh</code> to the target mesh</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">targetState</td><td>A <code>TargetState</code> for the data that will be mapped to the target mesh </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aac44f144a0a6f3495fcf3f51ed68e68e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac44f144a0a6f3495fcf3f51ed68e68e">&#9670;&nbsp;</a></span>CoreDriver() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int D, Entity_kind ONWHAT, class SourceMesh , class SourceState , class TargetMesh  = SourceMesh, class TargetState  = SourceState, template&lt; class, int, class, class &gt; class InterfaceReconstructorType = DummyInterfaceReconstructor, class Matpoly_Splitter  = void, class Matpoly_Clipper  = void, class CoordSys  = Wonton::DefaultCoordSys&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPortage_1_1CoreDriver.html">Portage::CoreDriver</a>&lt; D, ONWHAT, SourceMesh, SourceState, TargetMesh, TargetState, InterfaceReconstructorType, Matpoly_Splitter, Matpoly_Clipper, CoordSys &gt;::<a class="el" href="classPortage_1_1CoreDriver.html">CoreDriver</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPortage_1_1CoreDriver.html">CoreDriver</a>&lt; D, ONWHAT, SourceMesh, SourceState, TargetMesh, TargetState, InterfaceReconstructorType, Matpoly_Splitter, Matpoly_Clipper, CoordSys &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy constructor (disabled) </p>

</div>
</div>
<a id="a87c43d90b01f4c19cb2aa275eef82c51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87c43d90b01f4c19cb2aa275eef82c51">&#9670;&nbsp;</a></span>~CoreDriver()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int D, Entity_kind ONWHAT, class SourceMesh , class SourceState , class TargetMesh  = SourceMesh, class TargetState  = SourceState, template&lt; class, int, class, class &gt; class InterfaceReconstructorType = DummyInterfaceReconstructor, class Matpoly_Splitter  = void, class Matpoly_Clipper  = void, class CoordSys  = Wonton::DefaultCoordSys&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPortage_1_1CoreDriver.html">Portage::CoreDriver</a>&lt; D, ONWHAT, SourceMesh, SourceState, TargetMesh, TargetState, InterfaceReconstructorType, Matpoly_Splitter, Matpoly_Clipper, CoordSys &gt;::~<a class="el" href="classPortage_1_1CoreDriver.html">CoreDriver</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destructor. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a43bbaadd288f7637b5cd8d2fc4cd1f08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43bbaadd288f7637b5cd8d2fc4cd1f08">&#9670;&nbsp;</a></span>check_mismatch()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int D, Entity_kind ONWHAT, class SourceMesh , class SourceState , class TargetMesh  = SourceMesh, class TargetState  = SourceState, template&lt; class, int, class, class &gt; class InterfaceReconstructorType = DummyInterfaceReconstructor, class Matpoly_Splitter  = void, class Matpoly_Clipper  = void, class CoordSys  = Wonton::DefaultCoordSys&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classPortage_1_1CoreDriver.html">Portage::CoreDriver</a>&lt; D, ONWHAT, SourceMesh, SourceState, TargetMesh, TargetState, InterfaceReconstructorType, Matpoly_Splitter, Matpoly_Clipper, CoordSys &gt;::check_mismatch </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacePortage.html#ad86a06a9372f05948709ca73e058981d">Portage::vector</a>&lt; std::vector&lt; Weights_t &gt;&gt; const &amp;&#160;</td>
          <td class="paramname"><em>source_weights</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Check mismatch between meshes</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sources_and_weights</td><td>Intersection sources and moments (vols, centroids)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether the meshes are mismatched </dd></dl>

</div>
</div>
<a id="add913253c13d7646ad1a6331b27b816b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add913253c13d7646ad1a6331b27b816b">&#9670;&nbsp;</a></span>compute_source_gradient()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int D, Entity_kind ONWHAT, class SourceMesh , class SourceState , class TargetMesh  = SourceMesh, class TargetState  = SourceState, template&lt; class, int, class, class &gt; class InterfaceReconstructorType = DummyInterfaceReconstructor, class Matpoly_Splitter  = void, class Matpoly_Clipper  = void, class CoordSys  = Wonton::DefaultCoordSys&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacePortage.html#ad86a06a9372f05948709ca73e058981d">Portage::vector</a>&lt;Vector&lt;D&gt; &gt; <a class="el" href="classPortage_1_1CoreDriver.html">Portage::CoreDriver</a>&lt; D, ONWHAT, SourceMesh, SourceState, TargetMesh, TargetState, InterfaceReconstructorType, Matpoly_Splitter, Matpoly_Clipper, CoordSys &gt;::compute_source_gradient </td>
          <td>(</td>
          <td class="paramtype">std::string const&#160;</td>
          <td class="paramname"><em>field_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacePortage.html#a4cb59edee64edb5a23427c8cb2fb5be6">Limiter_type</a>&#160;</td>
          <td class="paramname"><em>limiter_type</em> = <code><a class="el" href="namespacePortage.html#a4cb59edee64edb5a23427c8cb2fb5be6a129ce73da39e28f090a4963952638f0f">NOLIMITER</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacePortage.html#a749d03d65d45c5468ee09f871868118f">Boundary_Limiter_type</a>&#160;</td>
          <td class="paramname"><em>boundary_limiter_type</em> = <code><a class="el" href="namespacePortage.html#a749d03d65d45c5468ee09f871868118fa7df68da5020422a2b128d16d534e07d4">BND_NOLIMITER</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>material_id</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPortage_1_1Part.html">Part</a>&lt; SourceMesh, SourceState &gt; *&#160;</td>
          <td class="paramname"><em>source_part</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the gradient field of the given variable on source mesh. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">field_name</td><td>the variable name. </td></tr>
    <tr><td class="paramname">limiter_type</td><td>gradient limiter to use on internal regions. </td></tr>
    <tr><td class="paramname">boundary_limiter_type</td><td>gradient limiter to use on boundary. </td></tr>
    <tr><td class="paramname">source_part</td><td>the source mesh part to consider if any. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af9e74e229b6c432fc6ddf18d3accfbb1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9e74e229b6c432fc6ddf18d3accfbb1">&#9670;&nbsp;</a></span>fix_mismatch()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int D, Entity_kind ONWHAT, class SourceMesh , class SourceState , class TargetMesh  = SourceMesh, class TargetState  = SourceState, template&lt; class, int, class, class &gt; class InterfaceReconstructorType = DummyInterfaceReconstructor, class Matpoly_Splitter  = void, class Matpoly_Clipper  = void, class CoordSys  = Wonton::DefaultCoordSys&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classPortage_1_1CoreDriver.html">Portage::CoreDriver</a>&lt; D, ONWHAT, SourceMesh, SourceState, TargetMesh, TargetState, InterfaceReconstructorType, Matpoly_Splitter, Matpoly_Clipper, CoordSys &gt;::fix_mismatch </td>
          <td>(</td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>src_var_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>trg_var_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>global_lower_bound</em> = <code>-std::numeric_limits&lt;double&gt;::max()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>global_upper_bound</em> = <code>std::numeric_limits&lt;double&gt;::max()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>conservation_tol</em> = <code>1e2*std::numeric_limits&lt;double&gt;::epsilon()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>maxiter</em> = <code>5</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacePortage.html#a14733964cb2a49126b6094ce7cbdeb1e">Partial_fixup_type</a>&#160;</td>
          <td class="paramname"><em>partial_fixup_type</em> = <code>Partial_fixup_type::SHIFTED_CONSERVATIVE</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacePortage.html#a98e23e534e4657cb05de2e35f5728dad">Empty_fixup_type</a>&#160;</td>
          <td class="paramname"><em>empty_fixup_type</em> = <code>Empty_fixup_type::EXTRAPOLATE</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Repair the remapped field to account for boundary mismatch. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src_var_name</td><td>field variable on source mesh </td></tr>
    <tr><td class="paramname">trg_var_name</td><td>field variable on target mesh </td></tr>
    <tr><td class="paramname">global_lower_bound</td><td>lower limit on variable </td></tr>
    <tr><td class="paramname">global_upper_bound</td><td>upper limit on variable </td></tr>
    <tr><td class="paramname">partial_fixup_type</td><td>type of fixup in case of partial mismatch </td></tr>
    <tr><td class="paramname">empty_fixup_type</td><td>type of fixup in empty target entities</td></tr>
  </table>
  </dd>
</dl>
<p>partial_fixup_type can be one of three types:</p>
<p>CONSTANT - Fields will see no perturbations BUT REMAP WILL BE NON-CONSERVATIVE (constant preserving, not linearity preserving) LOCALLY_CONSERVATIVE - REMAP WILL BE LOCALLY CONSERVATIVE (target cells will preserve the integral quantities received from source mesh overlap) but perturbations will occur in the field (constant fields may not stay constant if there is mismatch) SHIFTED_CONSERVATIVE - REMAP WILL BE CONSERVATIVE and field perturbations will be minimum but field values may be shifted (Constant fields will be shifted to different constant; no guarantees on linearity preservation)</p>
<p>empty_fixup_type can be one of two types:</p>
<p>LEAVE_EMPTY - Leave empty cells as is EXTRAPOLATE - Fill empty cells with extrapolated values FILL - Fill empty cells with specified values (not yet implemented) </p>

</div>
</div>
<a id="a44a5fd5d37ea0372e26a8838d90f0506"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44a5fd5d37ea0372e26a8838d90f0506">&#9670;&nbsp;</a></span>has_mismatch()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int D, Entity_kind ONWHAT, class SourceMesh , class SourceState , class TargetMesh  = SourceMesh, class TargetState  = SourceState, template&lt; class, int, class, class &gt; class InterfaceReconstructorType = DummyInterfaceReconstructor, class Matpoly_Splitter  = void, class Matpoly_Clipper  = void, class CoordSys  = Wonton::DefaultCoordSys&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classPortage_1_1CoreDriver.html">Portage::CoreDriver</a>&lt; D, ONWHAT, SourceMesh, SourceState, TargetMesh, TargetState, InterfaceReconstructorType, Matpoly_Splitter, Matpoly_Clipper, CoordSys &gt;::has_mismatch </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return mismatch between meshes</p>
<dl class="section return"><dt>Returns</dt><dd>Whether the meshes are mismatched </dd></dl>

</div>
</div>
<a id="ac3a4b73c1e2724321af8ee2ab81f6395"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3a4b73c1e2724321af8ee2ab81f6395">&#9670;&nbsp;</a></span>interpolate_mesh_var() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int D, Entity_kind ONWHAT, class SourceMesh , class SourceState , class TargetMesh  = SourceMesh, class TargetState  = SourceState, template&lt; class, int, class, class &gt; class InterfaceReconstructorType = DummyInterfaceReconstructor, class Matpoly_Splitter  = void, class Matpoly_Clipper  = void, class CoordSys  = Wonton::DefaultCoordSys&gt; </div>
<div class="memtemplate">
template&lt;typename T  = double, template&lt; int, Entity_kind, class, class, class, class, class, template&lt; class, int, class, class &gt; class, class, class, class &gt; class Interpolate&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classPortage_1_1CoreDriver.html">Portage::CoreDriver</a>&lt; D, ONWHAT, SourceMesh, SourceState, TargetMesh, TargetState, InterfaceReconstructorType, Matpoly_Splitter, Matpoly_Clipper, CoordSys &gt;::interpolate_mesh_var </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>srcvarname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>trgvarname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacePortage.html#ad86a06a9372f05948709ca73e058981d">Portage::vector</a>&lt; std::vector&lt; Weights_t &gt;&gt; const &amp;&#160;</td>
          <td class="paramname"><em>sources_and_weights</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacePortage.html#ad86a06a9372f05948709ca73e058981d">Portage::vector</a>&lt; Vector&lt; D &gt;&gt; *&#160;</td>
          <td class="paramname"><em>gradients</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Interpolate mesh variable. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">srcvarname</td><td>source mesh variable to remap </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">trgvarname</td><td>target mesh variable to remap </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sources_and_weights</td><td>weights for mesh-mesh interpolation </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">gradients</td><td>gradients of variable on source mesh (can be nullptr for 1st order remap) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2e0b38d71f560f23ea57c7b7baaad4c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e0b38d71f560f23ea57c7b7baaad4c1">&#9670;&nbsp;</a></span>interpolate_mesh_var() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int D, Entity_kind ONWHAT, class SourceMesh , class SourceState , class TargetMesh  = SourceMesh, class TargetState  = SourceState, template&lt; class, int, class, class &gt; class InterfaceReconstructorType = DummyInterfaceReconstructor, class Matpoly_Splitter  = void, class Matpoly_Clipper  = void, class CoordSys  = Wonton::DefaultCoordSys&gt; </div>
<div class="memtemplate">
template&lt;typename T  = double, template&lt; int, Entity_kind, class, class, class, class, class, template&lt; class, int, class, class &gt; class, class, class, class &gt; class Interpolate, Entity_kind ONWHAT1 = ONWHAT, typename  = typename std::enable_if&lt;ONWHAT1 == CELL&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classPortage_1_1CoreDriver.html">Portage::CoreDriver</a>&lt; D, ONWHAT, SourceMesh, SourceState, TargetMesh, TargetState, InterfaceReconstructorType, Matpoly_Splitter, Matpoly_Clipper, CoordSys &gt;::interpolate_mesh_var </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>srcvarname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>trgvarname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacePortage.html#ad86a06a9372f05948709ca73e058981d">Portage::vector</a>&lt; std::vector&lt; Weights_t &gt;&gt; const &amp;&#160;</td>
          <td class="paramname"><em>sources_and_weights</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPortage_1_1PartPair.html">PartPair</a>&lt; D, SourceMesh, SourceState, TargetMesh, TargetState &gt; *&#160;</td>
          <td class="paramname"><em>partition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacePortage.html#ad86a06a9372f05948709ca73e058981d">Portage::vector</a>&lt; Vector&lt; D &gt;&gt; *&#160;</td>
          <td class="paramname"><em>gradients</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Interpolate mesh variable from source part to target part. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">srcvarname</td><td>source mesh variable to remap </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">trgvarname</td><td>target mesh variable to remap </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sources_and_weights</td><td>weights for mesh-mesh interpolation </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lower_bound</td><td>lower bound of variable value </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">upper_bound</td><td>upper bound of variable value </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">partition</td><td>structure containing source and target part </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">gradients</td><td>gradients of variable on source mesh (can be nullptr for 1st order remap)</td></tr>
  </table>
  </dd>
</dl>
<p>Enable only for cells using SFINAE. Here the class, rather than the function is templated on ONWHAT (as opposed to the equivalent method in the base class); so we have to create a dummy template parameter ONWHAT1 and rely on that to use SFINAE with a <em>second</em> dummy template parameter </p><pre class="fragment"> Note ****
</pre><p> If you encounter errors about not being able to find an appropriate overload for interpolate_mesh_var in your application code (particularly something like "no type named 'type' in struct
std::enable_if&lt;false, void&gt;"), make sure the compiler does see the possiblity of calling this function with Entity_kinds that are not type CELL (restricting the code flow using 'if' statements will not be enough) </p>

</div>
</div>
<a id="a2748460fda1bf11f962f33a5756b0627"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2748460fda1bf11f962f33a5756b0627">&#9670;&nbsp;</a></span>intersect_materials()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int D, Entity_kind ONWHAT, class SourceMesh , class SourceState , class TargetMesh  = SourceMesh, class TargetState  = SourceState, template&lt; class, int, class, class &gt; class InterfaceReconstructorType = DummyInterfaceReconstructor, class Matpoly_Splitter  = void, class Matpoly_Clipper  = void, class CoordSys  = Wonton::DefaultCoordSys&gt; </div>
<div class="memtemplate">
template&lt;template&lt; Entity_kind, class, class, class, template&lt; class, int, class, class &gt; class, class, class &gt; class Intersect&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="namespacePortage.html#ad86a06a9372f05948709ca73e058981d">Portage::vector</a>&lt;std::vector&lt;Weights_t&gt; &gt; &gt; <a class="el" href="classPortage_1_1CoreDriver.html">Portage::CoreDriver</a>&lt; D, ONWHAT, SourceMesh, SourceState, TargetMesh, TargetState, InterfaceReconstructorType, Matpoly_Splitter, Matpoly_Clipper, CoordSys &gt;::intersect_materials </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacePortage.html#ad86a06a9372f05948709ca73e058981d">Portage::vector</a>&lt; std::vector&lt; int &gt;&gt; const &amp;&#160;</td>
          <td class="paramname"><em>candidates</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Intersect target mesh cells with source material polygons and return the intersecting entities and moments of intersection for each entity</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">candidates</td><td>Vector of intersection candidates for each target entity</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Material-wise vector of intersection moments for each target entity</dd></dl>
<p>NOTE: WE COULD SEND IN THE MESH-MESH INTERSECTION MOMENTS AND REUSE THEM IF A SOURCE CELL HAS ONLY ONE MATERIAL </p>

</div>
</div>
<a id="afd59ea61f292ed7cfdb5bc2f883ac2c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd59ea61f292ed7cfdb5bc2f883ac2c8">&#9670;&nbsp;</a></span>intersect_meshes()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int D, Entity_kind ONWHAT, class SourceMesh , class SourceState , class TargetMesh  = SourceMesh, class TargetState  = SourceState, template&lt; class, int, class, class &gt; class InterfaceReconstructorType = DummyInterfaceReconstructor, class Matpoly_Splitter  = void, class Matpoly_Clipper  = void, class CoordSys  = Wonton::DefaultCoordSys&gt; </div>
<div class="memtemplate">
template&lt;template&lt; Entity_kind, class, class, class, template&lt; class, int, class, class &gt; class, class, class &gt; class Intersect&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacePortage.html#ad86a06a9372f05948709ca73e058981d">Portage::vector</a>&lt;std::vector&lt;Portage::Weights_t&gt; &gt; <a class="el" href="classPortage_1_1CoreDriver.html">Portage::CoreDriver</a>&lt; D, ONWHAT, SourceMesh, SourceState, TargetMesh, TargetState, InterfaceReconstructorType, Matpoly_Splitter, Matpoly_Clipper, CoordSys &gt;::intersect_meshes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacePortage.html#ad86a06a9372f05948709ca73e058981d">Portage::vector</a>&lt; std::vector&lt; int &gt;&gt; const &amp;&#160;</td>
          <td class="paramname"><em>candidates</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Intersect source and target mesh entities of kind 'ONWHAT' and return the intersecting entities and moments of intersection for each entity</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">candidates</td><td>Vector of intersection candidates for each target entity</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector of intersection moments for each target entity </dd></dl>

</div>
</div>
<a id="acc5a4eb4f0a9bf447a4441efa9504632"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc5a4eb4f0a9bf447a4441efa9504632">&#9670;&nbsp;</a></span>onwhat()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int D, Entity_kind ONWHAT, class SourceMesh , class SourceState , class TargetMesh  = SourceMesh, class TargetState  = SourceState, template&lt; class, int, class, class &gt; class InterfaceReconstructorType = DummyInterfaceReconstructor, class Matpoly_Splitter  = void, class Matpoly_Clipper  = void, class CoordSys  = Wonton::DefaultCoordSys&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Entity_kind <a class="el" href="classPortage_1_1CoreDriver.html">Portage::CoreDriver</a>&lt; D, ONWHAT, SourceMesh, SourceState, TargetMesh, TargetState, InterfaceReconstructorType, Matpoly_Splitter, Matpoly_Clipper, CoordSys &gt;::onwhat </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>What entity kind is this defined on? </p>

<p>Implements <a class="el" href="classPortage_1_1CoreDriverBase.html#a1c92b2e5c7d607bbedf416f26f3adf4f">Portage::CoreDriverBase&lt; D, SourceMesh, SourceState, TargetMesh, TargetState, InterfaceReconstructorType, Matpoly_Splitter, Matpoly_Clipper, CoordSys &gt;</a>.</p>

</div>
</div>
<a id="abd29bbaa2f9ac5530d8896bb89935e23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd29bbaa2f9ac5530d8896bb89935e23">&#9670;&nbsp;</a></span>operator=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int D, Entity_kind ONWHAT, class SourceMesh , class SourceState , class TargetMesh  = SourceMesh, class TargetState  = SourceState, template&lt; class, int, class, class &gt; class InterfaceReconstructorType = DummyInterfaceReconstructor, class Matpoly_Splitter  = void, class Matpoly_Clipper  = void, class CoordSys  = Wonton::DefaultCoordSys&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPortage_1_1CoreDriver.html">CoreDriver</a>&amp; <a class="el" href="classPortage_1_1CoreDriver.html">Portage::CoreDriver</a>&lt; D, ONWHAT, SourceMesh, SourceState, TargetMesh, TargetState, InterfaceReconstructorType, Matpoly_Splitter, Matpoly_Clipper, CoordSys &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPortage_1_1CoreDriver.html">CoreDriver</a>&lt; D, ONWHAT, SourceMesh, SourceState, TargetMesh, TargetState, InterfaceReconstructorType, Matpoly_Splitter, Matpoly_Clipper, CoordSys &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assignment operator (disabled) </p>

</div>
</div>
<a id="adaa4df6ae5913f1f0abe8d24d6a0ef4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adaa4df6ae5913f1f0abe8d24d6a0ef4d">&#9670;&nbsp;</a></span>search()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int D, Entity_kind ONWHAT, class SourceMesh , class SourceState , class TargetMesh  = SourceMesh, class TargetState  = SourceState, template&lt; class, int, class, class &gt; class InterfaceReconstructorType = DummyInterfaceReconstructor, class Matpoly_Splitter  = void, class Matpoly_Clipper  = void, class CoordSys  = Wonton::DefaultCoordSys&gt; </div>
<div class="memtemplate">
template&lt;template&lt; int, Entity_kind, class, class &gt; class Search&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacePortage.html#ad86a06a9372f05948709ca73e058981d">Portage::vector</a>&lt;std::vector&lt;int&gt; &gt; <a class="el" href="classPortage_1_1CoreDriver.html">Portage::CoreDriver</a>&lt; D, ONWHAT, SourceMesh, SourceState, TargetMesh, TargetState, InterfaceReconstructorType, Matpoly_Splitter, Matpoly_Clipper, CoordSys &gt;::search </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Find candidates entities of a particular kind that might intersect each target entity of the same kind</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Search</td><td>Search class templated on dimension, Entity_kind and both meshes</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Vector of intersection candidates for each target entity </dd></dl>

</div>
</div>
<a id="ade0e76d3da30898b787e3072db0556e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade0e76d3da30898b787e3072db0556e3">&#9670;&nbsp;</a></span>set_num_tols() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int D, Entity_kind ONWHAT, class SourceMesh , class SourceState , class TargetMesh  = SourceMesh, class TargetState  = SourceState, template&lt; class, int, class, class &gt; class InterfaceReconstructorType = DummyInterfaceReconstructor, class Matpoly_Splitter  = void, class Matpoly_Clipper  = void, class CoordSys  = Wonton::DefaultCoordSys&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classPortage_1_1CoreDriver.html">Portage::CoreDriver</a>&lt; D, ONWHAT, SourceMesh, SourceState, TargetMesh, TargetState, InterfaceReconstructorType, Matpoly_Splitter, Matpoly_Clipper, CoordSys &gt;::set_num_tols </td>
          <td>(</td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>min_absolute_distance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>min_absolute_volume</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set core numerical tolerances. </p>

</div>
</div>
<a id="adb9ea0ac90f4aa09af3b83c714b870c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb9ea0ac90f4aa09af3b83c714b870c9">&#9670;&nbsp;</a></span>set_num_tols() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int D, Entity_kind ONWHAT, class SourceMesh , class SourceState , class TargetMesh  = SourceMesh, class TargetState  = SourceState, template&lt; class, int, class, class &gt; class InterfaceReconstructorType = DummyInterfaceReconstructor, class Matpoly_Splitter  = void, class Matpoly_Clipper  = void, class CoordSys  = Wonton::DefaultCoordSys&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classPortage_1_1CoreDriver.html">Portage::CoreDriver</a>&lt; D, ONWHAT, SourceMesh, SourceState, TargetMesh, TargetState, InterfaceReconstructorType, Matpoly_Splitter, Matpoly_Clipper, CoordSys &gt;::set_num_tols </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structPortage_1_1NumericTolerances__t.html">NumericTolerances_t</a> &amp;&#160;</td>
          <td class="paramname"><em>num_tols</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set all numerical tolerances. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/home/portage/portage/portage/driver/<a class="el" href="coredriver_8h_source.html">coredriver.h</a></li>
</ul>
</div><!-- contents -->
<!--
This file is part of the Ristra portage project.
Please see the license file at the root of this repository, or at:
    https://github.com/laristra/portage/blob/master/LICENSE
-->
<!-- HTML footer for doxygen 1.8.8-->
<!-- start footer part -->
</div>
</div>
</div>
</div>
</div>
<!--<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address> -->
<footer id="footer" class="footer">
  <div class="container">
    <div class="row test-muted">
      <div class="footer-row col-md-6">Copyright &copy; 2019
	<a href="http://lanl.gov"> Triad National Security, LLC</a>
	All Rights Reserved.
      </div>
      <div class="footer-row col-md-2">
	<a href="https://github.com/laristra/portage/blob/master/LICENSE">
	  BSD LICENSE
	</a>
      </div>
      <div class="footer-row col-md-2">
	LA-CC-16-084
      </div>
      <div class="footer-row col-md-1">
	<a href="mailto:portage@lanl.gov">
	  <i class="fa fa-envelope-o fa-2x"></i>
	</a>
      </div>
      <div class="footer-row col-md-1">
	<a href="https://github.com/laristra/portage">
	  <i class="fa fa-github fa-2x"></i>
	</a>
      </div>
    </div>
  </div>
</footer>
<script type="text/javascript" src="doxy-boot.js"></script>
</body>
</html>
