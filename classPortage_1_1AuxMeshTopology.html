<!--
This file is part of the Ristra portage project.
Please see the license file at the root of this repository, or at:
    https://github.com/laristra/portage/blob/master/LICENSE
-->
<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=edge"/>
    <!-- For Mobile Devices -->
    <meta name="viewport" content="width=device-width, initial-scale=1"/>
    <!-- Font stuff -->
    <link href='https://fonts.googleapis.com/css?family=Roboto+Slab' rel='stylesheet' type='text/css'/>
    <!-- Font Awesome -->
    <!--    <link rel="stylesheet" href="font-awesome-4.3.0/css/font-awesome.min.css"/> -->
    <script src="https://use.fontawesome.com/3dce4d8e65.js"></script>
    <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
    <meta name="generator" content="Doxygen 1.8.11"/>
    <script type="text/javascript" src="https://code.jquery.com/jquery-3.1.1.min.js"></script>
    <title>portage: Portage::AuxMeshTopology&lt; BasicMesh &gt; Class Template Reference</title>
    <script type="text/javascript" src="dynsections.js"></script>
    <link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
    <link href="doxygen.css" rel="stylesheet" type="text/css" />
    <link href="customdoxygen.css" rel="stylesheet" type="text/css"/>
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css"/>
    <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js"></script>
    <script type="text/javascript" src="doxy-boot.js"></script>
  </head>
  <body>
    <nav class="navbar navbar-default" role="navigation">
      <div class="container">
        <div class="navbar-header">
          <a class="navbar-brand">portage 1.1.0</a>
        </div>
      </div>
    </nav>
    <div id="top"><!-- do not remove this div, it is closed by doxygen! -->
      <div class="content" id="content">
        <div class="container">
          <div class="row">
            <div class="col-sm-12 panel " style="padding-bottom: 15px;">
              <div style="margin-bottom: 15px;">
		<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="concepts.html"><span>Concepts</span></a></li>
      <li><a href="example.html"><span>Example&#160;Use</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacePortage.html">Portage</a></li><li class="navelem"><a class="el" href="classPortage_1_1AuxMeshTopology.html">AuxMeshTopology</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classPortage_1_1AuxMeshTopology-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Portage::AuxMeshTopology&lt; BasicMesh &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="AuxMeshTopology_8h_source.html">AuxMeshTopology.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a020e994323b94fbbed00f82e34560ba1"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPortage_1_1AuxMeshTopology.html#a020e994323b94fbbed00f82e34560ba1">AuxMeshTopology</a> (bool request_sides=true, bool request_wedges=true, bool request_corners=true)</td></tr>
<tr class="memdesc:a020e994323b94fbbed00f82e34560ba1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor indicating which entities are wanted.  <a href="#a020e994323b94fbbed00f82e34560ba1">More...</a><br /></td></tr>
<tr class="separator:a020e994323b94fbbed00f82e34560ba1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30d2dfa1c20c71145fe898b1529b21d7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPortage_1_1AuxMeshTopology.html#a30d2dfa1c20c71145fe898b1529b21d7">num_owned_sides</a> () const </td></tr>
<tr class="memdesc:a30d2dfa1c20c71145fe898b1529b21d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of owned sides in the mesh.  <a href="#a30d2dfa1c20c71145fe898b1529b21d7">More...</a><br /></td></tr>
<tr class="separator:a30d2dfa1c20c71145fe898b1529b21d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae022c6b946032ed1d50d0b7957b483a2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPortage_1_1AuxMeshTopology.html#ae022c6b946032ed1d50d0b7957b483a2">num_owned_wedges</a> () const </td></tr>
<tr class="memdesc:ae022c6b946032ed1d50d0b7957b483a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of owned wedges in the mesh.  <a href="#ae022c6b946032ed1d50d0b7957b483a2">More...</a><br /></td></tr>
<tr class="separator:ae022c6b946032ed1d50d0b7957b483a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d5c48ae3a2d5ce6704a0ee5b17bfe1b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPortage_1_1AuxMeshTopology.html#a0d5c48ae3a2d5ce6704a0ee5b17bfe1b">num_owned_corners</a> () const </td></tr>
<tr class="memdesc:a0d5c48ae3a2d5ce6704a0ee5b17bfe1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of owned corners in the mesh.  <a href="#a0d5c48ae3a2d5ce6704a0ee5b17bfe1b">More...</a><br /></td></tr>
<tr class="separator:a0d5c48ae3a2d5ce6704a0ee5b17bfe1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9bb2bcd54b0d744d8a4082b65863534"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPortage_1_1AuxMeshTopology.html#ad9bb2bcd54b0d744d8a4082b65863534">num_ghost_sides</a> () const </td></tr>
<tr class="memdesc:ad9bb2bcd54b0d744d8a4082b65863534"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of ghost sides in the mesh.  <a href="#ad9bb2bcd54b0d744d8a4082b65863534">More...</a><br /></td></tr>
<tr class="separator:ad9bb2bcd54b0d744d8a4082b65863534"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c284523f9253c045d4c4652df0fdde0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPortage_1_1AuxMeshTopology.html#a0c284523f9253c045d4c4652df0fdde0">num_ghost_wedges</a> () const </td></tr>
<tr class="memdesc:a0c284523f9253c045d4c4652df0fdde0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of ghost wedges in the mesh.  <a href="#a0c284523f9253c045d4c4652df0fdde0">More...</a><br /></td></tr>
<tr class="separator:a0c284523f9253c045d4c4652df0fdde0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5c047de431dc1269c6defca71476147"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPortage_1_1AuxMeshTopology.html#aa5c047de431dc1269c6defca71476147">num_ghost_corners</a> () const </td></tr>
<tr class="memdesc:aa5c047de431dc1269c6defca71476147"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of ghost corners in the mesh.  <a href="#aa5c047de431dc1269c6defca71476147">More...</a><br /></td></tr>
<tr class="separator:aa5c047de431dc1269c6defca71476147"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72a7e33a70f9b88f974a377858e63f32"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPortage_1_1AuxMeshTopology.html#a72a7e33a70f9b88f974a377858e63f32">num_entities</a> (<a class="el" href="namespacePortage.html#a762e851d5a6ada63ea496d767679cffb">Entity_kind</a> const entity, <a class="el" href="namespacePortage.html#a650a8718a706648846a2915b90612849">Entity_type</a> const etype=Entity_type::ALL) const </td></tr>
<tr class="memdesc:a72a7e33a70f9b88f974a377858e63f32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of items of given entity.  <a href="#a72a7e33a70f9b88f974a377858e63f32">More...</a><br /></td></tr>
<tr class="separator:a72a7e33a70f9b88f974a377858e63f32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af43e0c21654b9c35d04f136325dfd5b0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacePortage.html#a5798f2be664fd95e54414f8aca5e3282">counting_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPortage_1_1AuxMeshTopology.html#af43e0c21654b9c35d04f136325dfd5b0">begin</a> (<a class="el" href="namespacePortage.html#a762e851d5a6ada63ea496d767679cffb">Entity_kind</a> const entity, <a class="el" href="namespacePortage.html#a650a8718a706648846a2915b90612849">Entity_type</a> const etype=Entity_type::ALL) const </td></tr>
<tr class="memdesc:af43e0c21654b9c35d04f136325dfd5b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterators on mesh entity - begin.  <a href="#af43e0c21654b9c35d04f136325dfd5b0">More...</a><br /></td></tr>
<tr class="separator:af43e0c21654b9c35d04f136325dfd5b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82379618ad2cd57f3362a26762eabe60"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacePortage.html#a5798f2be664fd95e54414f8aca5e3282">counting_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPortage_1_1AuxMeshTopology.html#a82379618ad2cd57f3362a26762eabe60">end</a> (<a class="el" href="namespacePortage.html#a762e851d5a6ada63ea496d767679cffb">Entity_kind</a> const entity, <a class="el" href="namespacePortage.html#a650a8718a706648846a2915b90612849">Entity_type</a> const etype=Entity_type::ALL) const </td></tr>
<tr class="memdesc:a82379618ad2cd57f3362a26762eabe60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterator on mesh entity - end.  <a href="#a82379618ad2cd57f3362a26762eabe60">More...</a><br /></td></tr>
<tr class="separator:a82379618ad2cd57f3362a26762eabe60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a230262249728d2e17f3856b6fb266820"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPortage_1_1AuxMeshTopology.html#a230262249728d2e17f3856b6fb266820">face_get_cells</a> (int const faceid, <a class="el" href="namespacePortage.html#a650a8718a706648846a2915b90612849">Entity_type</a> const etype, std::vector&lt; int &gt; *cells) const </td></tr>
<tr class="memdesc:a230262249728d2e17f3856b6fb266820"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get cells of given Entity_type connected to face (in no particular order)  <a href="#a230262249728d2e17f3856b6fb266820">More...</a><br /></td></tr>
<tr class="separator:a230262249728d2e17f3856b6fb266820"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10c5bf35b4c490316468ca7251d2a2b4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPortage_1_1AuxMeshTopology.html#a10c5bf35b4c490316468ca7251d2a2b4">on_exterior_boundary</a> (<a class="el" href="namespacePortage.html#a762e851d5a6ada63ea496d767679cffb">Entity_kind</a> const entity, int const entity_id) const </td></tr>
<tr class="memdesc:a10c5bf35b4c490316468ca7251d2a2b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">if entity is on exterior boundary  <a href="#a10c5bf35b4c490316468ca7251d2a2b4">More...</a><br /></td></tr>
<tr class="separator:a10c5bf35b4c490316468ca7251d2a2b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab43cbdf56afaa72d8b346835495184c2"><td class="memTemplParams" colspan="2">template&lt;long D&gt; </td></tr>
<tr class="memitem:ab43cbdf56afaa72d8b346835495184c2"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classPortage_1_1AuxMeshTopology.html#ab43cbdf56afaa72d8b346835495184c2">cell_get_coordinates</a> (int const cellid, std::vector&lt; <a class="el" href="classPortage_1_1Point.html">Point</a>&lt; D &gt;&gt; *pplist) const </td></tr>
<tr class="memdesc:ab43cbdf56afaa72d8b346835495184c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Coordinates of nodes of cell.  <a href="#ab43cbdf56afaa72d8b346835495184c2">More...</a><br /></td></tr>
<tr class="separator:ab43cbdf56afaa72d8b346835495184c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6be1d0af72ed2cb14eaff3d3f3725856"><td class="memTemplParams" colspan="2">template&lt;long D&gt; </td></tr>
<tr class="memitem:a6be1d0af72ed2cb14eaff3d3f3725856"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classPortage_1_1AuxMeshTopology.html#a6be1d0af72ed2cb14eaff3d3f3725856">cell_centroid</a> (int const cellid, <a class="el" href="classPortage_1_1Point.html">Point</a>&lt; D &gt; *ccen) const </td></tr>
<tr class="memdesc:a6be1d0af72ed2cb14eaff3d3f3725856"><td class="mdescLeft">&#160;</td><td class="mdescRight">Centroid of a cell.  <a href="#a6be1d0af72ed2cb14eaff3d3f3725856">More...</a><br /></td></tr>
<tr class="separator:a6be1d0af72ed2cb14eaff3d3f3725856"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15ed249e53a5d560d3120fd7007ccf57"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPortage_1_1AuxMeshTopology.html#a15ed249e53a5d560d3120fd7007ccf57">cell_volume</a> (int const cellid) const </td></tr>
<tr class="memdesc:a15ed249e53a5d560d3120fd7007ccf57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Volume of a cell.  <a href="#a15ed249e53a5d560d3120fd7007ccf57">More...</a><br /></td></tr>
<tr class="separator:a15ed249e53a5d560d3120fd7007ccf57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0d115f18705de06201687c129d6b6a2"><td class="memTemplParams" colspan="2">template&lt;long D&gt; </td></tr>
<tr class="memitem:ab0d115f18705de06201687c129d6b6a2"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classPortage_1_1AuxMeshTopology.html#ab0d115f18705de06201687c129d6b6a2">face_centroid</a> (int const faceid, <a class="el" href="classPortage_1_1Point.html">Point</a>&lt; D &gt; *fcen) const </td></tr>
<tr class="memdesc:ab0d115f18705de06201687c129d6b6a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Centroid of a face.  <a href="#ab0d115f18705de06201687c129d6b6a2">More...</a><br /></td></tr>
<tr class="separator:ab0d115f18705de06201687c129d6b6a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2f47c3477cdae0b4ab1122d0e36c2e0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPortage_1_1AuxMeshTopology.html#ae2f47c3477cdae0b4ab1122d0e36c2e0">side_get_node</a> (int const sideid, int const inode) const </td></tr>
<tr class="separator:ae2f47c3477cdae0b4ab1122d0e36c2e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1f5bca2e914e77ed0855b31a2ead164"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPortage_1_1AuxMeshTopology.html#af1f5bca2e914e77ed0855b31a2ead164">side_get_cell</a> (int const sideid) const </td></tr>
<tr class="memdesc:af1f5bca2e914e77ed0855b31a2ead164"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cell of side.  <a href="#af1f5bca2e914e77ed0855b31a2ead164">More...</a><br /></td></tr>
<tr class="separator:af1f5bca2e914e77ed0855b31a2ead164"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad27b0b53dec4105ad4eb5a333e298349"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPortage_1_1AuxMeshTopology.html#ad27b0b53dec4105ad4eb5a333e298349">side_get_face</a> (int const sideid) const </td></tr>
<tr class="memdesc:ad27b0b53dec4105ad4eb5a333e298349"><td class="mdescLeft">&#160;</td><td class="mdescRight">Face of side.  <a href="#ad27b0b53dec4105ad4eb5a333e298349">More...</a><br /></td></tr>
<tr class="separator:ad27b0b53dec4105ad4eb5a333e298349"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c0b77165a9f734eb6ee258e8837dd07"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPortage_1_1AuxMeshTopology.html#a7c0b77165a9f734eb6ee258e8837dd07">side_get_wedge</a> (int const sideid, int iwedge) const </td></tr>
<tr class="separator:a7c0b77165a9f734eb6ee258e8837dd07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a874888cd2685266bd2c0a06b315b2d8e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPortage_1_1AuxMeshTopology.html#a874888cd2685266bd2c0a06b315b2d8e">side_get_opposite_side</a> (int const sideid) const </td></tr>
<tr class="separator:a874888cd2685266bd2c0a06b315b2d8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67af8f0fa78afa7001b34f6722290a7b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPortage_1_1AuxMeshTopology.html#a67af8f0fa78afa7001b34f6722290a7b">cell_get_sides</a> (int const cellid, std::vector&lt; int &gt; *csides) const </td></tr>
<tr class="memdesc:a67af8f0fa78afa7001b34f6722290a7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get all the sides of a cell.  <a href="#a67af8f0fa78afa7001b34f6722290a7b">More...</a><br /></td></tr>
<tr class="separator:a67af8f0fa78afa7001b34f6722290a7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a2da0d50dc07ccf05e661e79e84310c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPortage_1_1AuxMeshTopology.html#a4a2da0d50dc07ccf05e661e79e84310c">side_get_coordinates</a> (int const sideid, std::array&lt; <a class="el" href="classPortage_1_1Point.html">Point</a>&lt; 3 &gt;, 4 &gt; *scoords, bool posvol_order=false) const </td></tr>
<tr class="memdesc:a4a2da0d50dc07ccf05e661e79e84310c"><td class="mdescLeft">&#160;</td><td class="mdescRight">side coordinates in 3D  <a href="#a4a2da0d50dc07ccf05e661e79e84310c">More...</a><br /></td></tr>
<tr class="separator:a4a2da0d50dc07ccf05e661e79e84310c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae78e6ebc7ae90a5d22671e4893a562a7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPortage_1_1AuxMeshTopology.html#ae78e6ebc7ae90a5d22671e4893a562a7">side_get_coordinates</a> (int const sideid, std::array&lt; <a class="el" href="classPortage_1_1Point.html">Point</a>&lt; 2 &gt;, 3 &gt; *scoords, bool posvol_order=false) const </td></tr>
<tr class="memdesc:ae78e6ebc7ae90a5d22671e4893a562a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">side coordinates in 2D  <a href="#ae78e6ebc7ae90a5d22671e4893a562a7">More...</a><br /></td></tr>
<tr class="separator:ae78e6ebc7ae90a5d22671e4893a562a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99f30c7d9ebaecdc55d73ca191093641"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPortage_1_1AuxMeshTopology.html#a99f30c7d9ebaecdc55d73ca191093641">side_get_coordinates</a> (int const sideid, std::array&lt; <a class="el" href="classPortage_1_1Point.html">Point</a>&lt; 1 &gt;, 2 &gt; *scoords, bool posvol_order=false) const </td></tr>
<tr class="memdesc:a99f30c7d9ebaecdc55d73ca191093641"><td class="mdescLeft">&#160;</td><td class="mdescRight">side coordinates in 1D  <a href="#a99f30c7d9ebaecdc55d73ca191093641">More...</a><br /></td></tr>
<tr class="separator:a99f30c7d9ebaecdc55d73ca191093641"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1be9d032ebed72415e602371981999cd"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPortage_1_1AuxMeshTopology.html#a1be9d032ebed72415e602371981999cd">side_volume</a> (int const sideid) const </td></tr>
<tr class="memdesc:a1be9d032ebed72415e602371981999cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Volume of a side.  <a href="#a1be9d032ebed72415e602371981999cd">More...</a><br /></td></tr>
<tr class="separator:a1be9d032ebed72415e602371981999cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a756ba7c43fbc390ac3167e1dea284260"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPortage_1_1AuxMeshTopology.html#a756ba7c43fbc390ac3167e1dea284260">wedge_get_side</a> (int const wedgeid) const </td></tr>
<tr class="memdesc:a756ba7c43fbc390ac3167e1dea284260"><td class="mdescLeft">&#160;</td><td class="mdescRight">Side of wedge.  <a href="#a756ba7c43fbc390ac3167e1dea284260">More...</a><br /></td></tr>
<tr class="separator:a756ba7c43fbc390ac3167e1dea284260"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e7eb658889fd89583c2813172cef6df"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPortage_1_1AuxMeshTopology.html#a6e7eb658889fd89583c2813172cef6df">wedge_get_cell</a> (int const wedgeid) const </td></tr>
<tr class="memdesc:a6e7eb658889fd89583c2813172cef6df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cell of wedge.  <a href="#a6e7eb658889fd89583c2813172cef6df">More...</a><br /></td></tr>
<tr class="separator:a6e7eb658889fd89583c2813172cef6df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a009684aea2a5087b45c5f1a124e528df"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPortage_1_1AuxMeshTopology.html#a009684aea2a5087b45c5f1a124e528df">wedge_get_face</a> (int const wedgeid) const </td></tr>
<tr class="memdesc:a009684aea2a5087b45c5f1a124e528df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Face of wedge.  <a href="#a009684aea2a5087b45c5f1a124e528df">More...</a><br /></td></tr>
<tr class="separator:a009684aea2a5087b45c5f1a124e528df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8124cedabe156104c4f76dd5e418bb29"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPortage_1_1AuxMeshTopology.html#a8124cedabe156104c4f76dd5e418bb29">wedge_get_corner</a> (int const wedgeid) const </td></tr>
<tr class="memdesc:a8124cedabe156104c4f76dd5e418bb29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Corner of a wedge.  <a href="#a8124cedabe156104c4f76dd5e418bb29">More...</a><br /></td></tr>
<tr class="separator:a8124cedabe156104c4f76dd5e418bb29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b4caa22cb89665cf8339ff2ebcb26b9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPortage_1_1AuxMeshTopology.html#a6b4caa22cb89665cf8339ff2ebcb26b9">wedge_get_node</a> (int const wedgeid) const </td></tr>
<tr class="memdesc:a6b4caa22cb89665cf8339ff2ebcb26b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">node of a wedge  <a href="#a6b4caa22cb89665cf8339ff2ebcb26b9">More...</a><br /></td></tr>
<tr class="separator:a6b4caa22cb89665cf8339ff2ebcb26b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a447ed49682700d8fd4ce7899461bfdca"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPortage_1_1AuxMeshTopology.html#a447ed49682700d8fd4ce7899461bfdca">wedge_get_opposite_wedge</a> (const int wedgeid) const </td></tr>
<tr class="separator:a447ed49682700d8fd4ce7899461bfdca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b463da92bd4cf6eb8b00a4627ad9638"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPortage_1_1AuxMeshTopology.html#a7b463da92bd4cf6eb8b00a4627ad9638">wedge_get_adjacent_wedge</a> (const int wedgeid) const </td></tr>
<tr class="separator:a7b463da92bd4cf6eb8b00a4627ad9638"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2780b35f909befb2825800504bb4b86f"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPortage_1_1AuxMeshTopology.html#a2780b35f909befb2825800504bb4b86f">wedge_volume</a> (int const wedgeid) const </td></tr>
<tr class="memdesc:a2780b35f909befb2825800504bb4b86f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Volume of a wedge - half its side volume.  <a href="#a2780b35f909befb2825800504bb4b86f">More...</a><br /></td></tr>
<tr class="separator:a2780b35f909befb2825800504bb4b86f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a320775062103d12237875af6f56a16e9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPortage_1_1AuxMeshTopology.html#a320775062103d12237875af6f56a16e9">wedge_get_coordinates</a> (int const wedgeid, std::array&lt; <a class="el" href="classPortage_1_1Point.html">Point</a>&lt; 3 &gt;, 4 &gt; *wcoords, bool posvol_order=false) const </td></tr>
<tr class="memdesc:a320775062103d12237875af6f56a16e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wedge coordinates in 3D.  <a href="#a320775062103d12237875af6f56a16e9">More...</a><br /></td></tr>
<tr class="separator:a320775062103d12237875af6f56a16e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6760ae4be65a18d40445a1e218d87d0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPortage_1_1AuxMeshTopology.html#ad6760ae4be65a18d40445a1e218d87d0">wedge_get_coordinates</a> (int const wedgeid, std::array&lt; <a class="el" href="classPortage_1_1Point.html">Point</a>&lt; 2 &gt;, 3 &gt; *wcoords, bool posvol_order=false) const </td></tr>
<tr class="memdesc:ad6760ae4be65a18d40445a1e218d87d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wedge coordinates in 2D.  <a href="#ad6760ae4be65a18d40445a1e218d87d0">More...</a><br /></td></tr>
<tr class="separator:ad6760ae4be65a18d40445a1e218d87d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cd146bd784301fa2778fb324dc3b6ac"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPortage_1_1AuxMeshTopology.html#a5cd146bd784301fa2778fb324dc3b6ac">wedge_get_coordinates</a> (int const wedgeid, std::array&lt; <a class="el" href="classPortage_1_1Point.html">Point</a>&lt; 1 &gt;, 2 &gt; *wcoords, bool posvol_order=false) const </td></tr>
<tr class="memdesc:a5cd146bd784301fa2778fb324dc3b6ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wedge coordinates in 1D.  <a href="#a5cd146bd784301fa2778fb324dc3b6ac">More...</a><br /></td></tr>
<tr class="separator:a5cd146bd784301fa2778fb324dc3b6ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0455fd7775ee46a9a48fb834e4f73c4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPortage_1_1AuxMeshTopology.html#ad0455fd7775ee46a9a48fb834e4f73c4">cell_get_wedges</a> (int const cellid, std::vector&lt; int &gt; *wedgeids) const </td></tr>
<tr class="memdesc:ad0455fd7775ee46a9a48fb834e4f73c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get all the wedges in a cell.  <a href="#ad0455fd7775ee46a9a48fb834e4f73c4">More...</a><br /></td></tr>
<tr class="separator:ad0455fd7775ee46a9a48fb834e4f73c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8d18194e614c90d14f3db7fef560061"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPortage_1_1AuxMeshTopology.html#ae8d18194e614c90d14f3db7fef560061">node_get_wedges</a> (int const nodeid, <a class="el" href="namespacePortage.html#a650a8718a706648846a2915b90612849">Entity_type</a> const type, std::vector&lt; int &gt; *wedgeids) const </td></tr>
<tr class="memdesc:ae8d18194e614c90d14f3db7fef560061"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get wedges at a node.  <a href="#ae8d18194e614c90d14f3db7fef560061">More...</a><br /></td></tr>
<tr class="separator:ae8d18194e614c90d14f3db7fef560061"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad31237dd7201ce17d96ebe7afc27bdf6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPortage_1_1AuxMeshTopology.html#ad31237dd7201ce17d96ebe7afc27bdf6">corner_get_node</a> (const int cornerid) const </td></tr>
<tr class="memdesc:ad31237dd7201ce17d96ebe7afc27bdf6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get node of corner.  <a href="#ad31237dd7201ce17d96ebe7afc27bdf6">More...</a><br /></td></tr>
<tr class="separator:ad31237dd7201ce17d96ebe7afc27bdf6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3631d51c16a3ed0af0bbc66461d968a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPortage_1_1AuxMeshTopology.html#aa3631d51c16a3ed0af0bbc66461d968a">corner_get_cell</a> (int const cornerid) const </td></tr>
<tr class="memdesc:aa3631d51c16a3ed0af0bbc66461d968a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get cell of corner.  <a href="#aa3631d51c16a3ed0af0bbc66461d968a">More...</a><br /></td></tr>
<tr class="separator:aa3631d51c16a3ed0af0bbc66461d968a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acaafd2587004e8239ec8392de6a31e12"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPortage_1_1AuxMeshTopology.html#acaafd2587004e8239ec8392de6a31e12">corner_get_wedges</a> (int const cornerid, std::vector&lt; int &gt; *wedgeids) const </td></tr>
<tr class="memdesc:acaafd2587004e8239ec8392de6a31e12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get wedges of a corner.  <a href="#acaafd2587004e8239ec8392de6a31e12">More...</a><br /></td></tr>
<tr class="separator:acaafd2587004e8239ec8392de6a31e12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23fef51fa96d7264539a1887b8a6979a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPortage_1_1AuxMeshTopology.html#a23fef51fa96d7264539a1887b8a6979a">node_get_corners</a> (int const nodeid, <a class="el" href="namespacePortage.html#a650a8718a706648846a2915b90612849">Entity_type</a> const type, std::vector&lt; int &gt; *cornerids) const </td></tr>
<tr class="memdesc:a23fef51fa96d7264539a1887b8a6979a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get corners connected to a node.  <a href="#a23fef51fa96d7264539a1887b8a6979a">More...</a><br /></td></tr>
<tr class="separator:a23fef51fa96d7264539a1887b8a6979a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93f5f891f5556fdc48c0cbd639e82f54"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPortage_1_1AuxMeshTopology.html#a93f5f891f5556fdc48c0cbd639e82f54">cell_get_corners</a> (int const cellid, std::vector&lt; int &gt; *cornerids) const </td></tr>
<tr class="memdesc:a93f5f891f5556fdc48c0cbd639e82f54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get corners in a cell.  <a href="#a93f5f891f5556fdc48c0cbd639e82f54">More...</a><br /></td></tr>
<tr class="separator:a93f5f891f5556fdc48c0cbd639e82f54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace0177f9c1529cd05c2894fc53bd03ec"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPortage_1_1AuxMeshTopology.html#ace0177f9c1529cd05c2894fc53bd03ec">cell_get_corner_at_node</a> (int const cellid, int const nodeid) const </td></tr>
<tr class="memdesc:ace0177f9c1529cd05c2894fc53bd03ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a cell's corner at a particular node of the cell.  <a href="#ace0177f9c1529cd05c2894fc53bd03ec">More...</a><br /></td></tr>
<tr class="separator:ace0177f9c1529cd05c2894fc53bd03ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f12e9e2bcbee63d12a69c432db76391"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPortage_1_1AuxMeshTopology.html#a6f12e9e2bcbee63d12a69c432db76391">corner_volume</a> (int const cornerid) const </td></tr>
<tr class="memdesc:a6f12e9e2bcbee63d12a69c432db76391"><td class="mdescLeft">&#160;</td><td class="mdescRight">Volume of a corner.  <a href="#a6f12e9e2bcbee63d12a69c432db76391">More...</a><br /></td></tr>
<tr class="separator:a6f12e9e2bcbee63d12a69c432db76391"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f535d17b2e4954f595f337e4fb8515b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPortage_1_1AuxMeshTopology.html#a5f535d17b2e4954f595f337e4fb8515b">decompose_cell_into_tets</a> (int cellid, std::vector&lt; std::array&lt; <a class="el" href="classPortage_1_1Point.html">Portage::Point</a>&lt; 3 &gt;, 4 &gt;&gt; *tcoords, const bool planar_hex) const </td></tr>
<tr class="memdesc:a5f535d17b2e4954f595f337e4fb8515b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the simplest possible decomposition of a 3D cell into tets.  <a href="#a5f535d17b2e4954f595f337e4fb8515b">More...</a><br /></td></tr>
<tr class="separator:a5f535d17b2e4954f595f337e4fb8515b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bd3333d1a55c902e74c8d2ac037d2c6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPortage_1_1AuxMeshTopology.html#a2bd3333d1a55c902e74c8d2ac037d2c6">dual_cell_get_coordinates</a> (int const nodeid, std::vector&lt; <a class="el" href="classPortage_1_1Point.html">Point</a>&lt; 2 &gt;&gt; *pplist) const </td></tr>
<tr class="memdesc:a2bd3333d1a55c902e74c8d2ac037d2c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">2D version of coords of nodes of a dual cell  <a href="#a2bd3333d1a55c902e74c8d2ac037d2c6">More...</a><br /></td></tr>
<tr class="separator:a2bd3333d1a55c902e74c8d2ac037d2c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00c603b05fea6a12b1ba7f1f08598d77"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPortage_1_1AuxMeshTopology.html#a00c603b05fea6a12b1ba7f1f08598d77">order_wedges_ccw</a> (std::vector&lt; int &gt; *wedgeids) const </td></tr>
<tr class="memdesc:a00c603b05fea6a12b1ba7f1f08598d77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Order wedges around a node in ccw manner.  <a href="#a00c603b05fea6a12b1ba7f1f08598d77">More...</a><br /></td></tr>
<tr class="separator:a00c603b05fea6a12b1ba7f1f08598d77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a827d5d76a49f65ad11b03e899fee0bef"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPortage_1_1AuxMeshTopology.html#a827d5d76a49f65ad11b03e899fee0bef">ccw</a> (<a class="el" href="classPortage_1_1Point.html">Point</a>&lt; 2 &gt; const &amp;p1, <a class="el" href="classPortage_1_1Point.html">Point</a>&lt; 2 &gt; const &amp;p2, <a class="el" href="classPortage_1_1Point.html">Point</a>&lt; 2 &gt; const &amp;p3) const </td></tr>
<tr class="separator:a827d5d76a49f65ad11b03e899fee0bef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7eddb95eaed6deea04342beb709498bf"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classPortage_1_1Point.html">Point</a>&lt; 2 &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPortage_1_1AuxMeshTopology.html#a7eddb95eaed6deea04342beb709498bf">cellToXY</a> (int cellID) const </td></tr>
<tr class="separator:a7eddb95eaed6deea04342beb709498bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add075adccbeaa188f85fab3db06f73e8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPortage_1_1AuxMeshTopology.html#add075adccbeaa188f85fab3db06f73e8">wedges_get_coordinates</a> (int cellID, std::vector&lt; std::array&lt; <a class="el" href="classPortage_1_1Point.html">Point</a>&lt; 3 &gt;, 4 &gt;&gt; *wcoords) const </td></tr>
<tr class="memdesc:add075adccbeaa188f85fab3db06f73e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get coordinates of wedge in 3D.  <a href="#add075adccbeaa188f85fab3db06f73e8">More...</a><br /></td></tr>
<tr class="separator:add075adccbeaa188f85fab3db06f73e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ae14f060ebdc46669277e7b415dcfec"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPortage_1_1AuxMeshTopology.html#a1ae14f060ebdc46669277e7b415dcfec">sides_get_coordinates</a> (int cellID, std::vector&lt; std::array&lt; <a class="el" href="classPortage_1_1Point.html">Point</a>&lt; 3 &gt;, 4 &gt;&gt; *scoords) const </td></tr>
<tr class="memdesc:a1ae14f060ebdc46669277e7b415dcfec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get coordinates of side in 3D.  <a href="#a1ae14f060ebdc46669277e7b415dcfec">More...</a><br /></td></tr>
<tr class="separator:a1ae14f060ebdc46669277e7b415dcfec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a943d4e2b5e2cb865d3479040d4cb032d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPortage_1_1AuxMeshTopology.html#a943d4e2b5e2cb865d3479040d4cb032d">dual_cell_get_node_adj_cells</a> (int const nodeid, <a class="el" href="namespacePortage.html#a650a8718a706648846a2915b90612849">Entity_type</a> const ptype, std::vector&lt; int &gt; *adjnodes) const </td></tr>
<tr class="memdesc:a943d4e2b5e2cb865d3479040d4cb032d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get adjacent "dual cells" of a given "dual cell".  <a href="#a943d4e2b5e2cb865d3479040d4cb032d">More...</a><br /></td></tr>
<tr class="separator:a943d4e2b5e2cb865d3479040d4cb032d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbd99a988c1b4098b1bf205844302ee4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPortage_1_1AuxMeshTopology.html#afbd99a988c1b4098b1bf205844302ee4">dual_cell_get_coordinates</a> (int const nodeid, std::vector&lt; <a class="el" href="classPortage_1_1Point.html">Point</a>&lt; 3 &gt;&gt; *pplist) const </td></tr>
<tr class="memdesc:afbd99a988c1b4098b1bf205844302ee4"><td class="mdescLeft">&#160;</td><td class="mdescRight">3D version of coords of nodes of a dual cell  <a href="#afbd99a988c1b4098b1bf205844302ee4">More...</a><br /></td></tr>
<tr class="separator:afbd99a988c1b4098b1bf205844302ee4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8614b63a071dae828055ee89ea925d0c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPortage_1_1AuxMeshTopology.html#a8614b63a071dae828055ee89ea925d0c">dual_wedges_get_coordinates</a> (int nodeid, std::vector&lt; std::array&lt; <a class="el" href="classPortage_1_1Point.html">Point</a>&lt; 3 &gt;, 4 &gt;&gt; *wcoords) const </td></tr>
<tr class="separator:a8614b63a071dae828055ee89ea925d0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa553ac201acbcc2856a1b97fcb2c5edc"><td class="memTemplParams" colspan="2">template&lt;long D&gt; </td></tr>
<tr class="memitem:aa553ac201acbcc2856a1b97fcb2c5edc"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classPortage_1_1AuxMeshTopology.html#aa553ac201acbcc2856a1b97fcb2c5edc">dual_cell_centroid</a> (int nodeid, <a class="el" href="classPortage_1_1Point.html">Point</a>&lt; D &gt; *centroid) const </td></tr>
<tr class="memdesc:aa553ac201acbcc2856a1b97fcb2c5edc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Centroid of a dual cell.  <a href="#aa553ac201acbcc2856a1b97fcb2c5edc">More...</a><br /></td></tr>
<tr class="separator:aa553ac201acbcc2856a1b97fcb2c5edc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a313c9f2e0255507a4c3943feaebdf1ba"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPortage_1_1AuxMeshTopology.html#a313c9f2e0255507a4c3943feaebdf1ba">dual_cell_volume</a> (int const nodeid) const </td></tr>
<tr class="memdesc:a313c9f2e0255507a4c3943feaebdf1ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the volume of dual cell by finding the corners that attach to the node.  <a href="#a313c9f2e0255507a4c3943feaebdf1ba">More...</a><br /></td></tr>
<tr class="separator:a313c9f2e0255507a4c3943feaebdf1ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a245b18dcd54213270f3b28d84a1ab0d0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPortage_1_1AuxMeshTopology.html#a245b18dcd54213270f3b28d84a1ab0d0">build_aux_entities</a> ()</td></tr>
<tr class="separator:a245b18dcd54213270f3b28d84a1ab0d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:ae3d64c4b8ca10e92cae57654e1a021b9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPortage_1_1AuxMeshTopology.html#ae3d64c4b8ca10e92cae57654e1a021b9">build_sides_1D</a> (<a class="el" href="classPortage_1_1AuxMeshTopology.html">AuxMeshTopology</a>&lt; BasicMesh &gt; &amp;mesh)</td></tr>
<tr class="separator:ae3d64c4b8ca10e92cae57654e1a021b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7e5f2ed32d0f63e3fbf9586cf38a6c8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPortage_1_1AuxMeshTopology.html#aa7e5f2ed32d0f63e3fbf9586cf38a6c8">build_sides_2D</a> (<a class="el" href="classPortage_1_1AuxMeshTopology.html">AuxMeshTopology</a>&lt; BasicMesh &gt; &amp;mesh)</td></tr>
<tr class="separator:aa7e5f2ed32d0f63e3fbf9586cf38a6c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad65c6b6888f43baabe341385246c9718"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPortage_1_1AuxMeshTopology.html#ad65c6b6888f43baabe341385246c9718">build_sides_3D</a> (<a class="el" href="classPortage_1_1AuxMeshTopology.html">AuxMeshTopology</a>&lt; BasicMesh &gt; &amp;mesh)</td></tr>
<tr class="separator:ad65c6b6888f43baabe341385246c9718"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename BasicMesh&gt;<br />
class Portage::AuxMeshTopology&lt; BasicMesh &gt;</h3>

<p>2D: A side is a triangle formed by the two nodes of an edge/face and the cell center. A wedge is half of a side formed by one node of the edge, the edge center and the cell center. A corner is a quadrilateral formed by the two wedges in a cell at a node</p>
<p>3D: A side is a tet formed by the two nodes of an edge, a face center and a cell center. A wedge is half a side, formed by a node of the edge, the edge center, the face center and the cell center. A corner is formed by all the wedges of a cell at a node.</p>
<p>The basic mesh class must support cells, faces and nodes and adjacency queries between these entities (In 2D, faces are the same as edges and in 1D, faces are the same as nodes). In particular, the basic mesh class is expected to support the following methods to successfully instantiate this class:</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> space_dimension() <span class="keyword">const</span>;  <span class="comment">// dimensionality of mesh points (1, 2, 3)</span></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> num_owned_cells() <span class="keyword">const</span>;</div><div class="line"><span class="keywordtype">int</span> num_ghost_cells() <span class="keyword">const</span>;</div><div class="line"><span class="keywordtype">int</span> num_owned_faces() <span class="keyword">const</span>;</div><div class="line"><span class="keywordtype">int</span> num_ghost_faces() <span class="keyword">const</span>;</div><div class="line"><span class="keywordtype">int</span> num_owned_nodes() <span class="keyword">const</span>;</div><div class="line"><span class="keywordtype">int</span> num_ghost_nodes() <span class="keyword">const</span>;</div><div class="line"><a class="code" href="namespacePortage.html#a650a8718a706648846a2915b90612849">Portage::Entity_type</a> cell_get_type(<span class="keywordtype">int</span> <span class="keyword">const</span> cellid) <span class="keyword">const</span>;</div></div><!-- fragment --><p>NOTE: Entity_type is Portage::OWNED or Portage::GHOST</p>
<div class="fragment"><div class="line"><a class="code" href="namespacePortage.html#a5f4ff6a944b45b72c32db1338353486b">Portage::Element_type</a> cell_get_element_type(<span class="keywordtype">int</span> <span class="keyword">const</span> cellid) <span class="keyword">const</span>;</div></div><!-- fragment --><p>Can be <a class="el" href="namespacePortage.html#a5f4ff6a944b45b72c32db1338353486ba263fddaa4929caea37151f274c36c3b8">Portage::UNKNOWN_TOPOLOGY</a>, <a class="el" href="namespacePortage.html#a5f4ff6a944b45b72c32db1338353486bace6f2b0c92efc89f01efe119c48ed5dc">Portage::TRI</a>, <a class="el" href="namespacePortage.html#a5f4ff6a944b45b72c32db1338353486ba8d7a47c1d94fd06ff47ed28caea231c2">Portage::QUAD</a>, <a class="el" href="namespacePortage.html#a5f4ff6a944b45b72c32db1338353486ba4b0049d4c1a57117404e9b28506d8135">Portage::POLYGON</a>, <a class="el" href="namespacePortage.html#a5f4ff6a944b45b72c32db1338353486ba7f8ef541756727c401aaf89d0ac5b2bf">Portage::TET</a>, <a class="el" href="namespacePortage.html#a5f4ff6a944b45b72c32db1338353486ba56d07f6b7a3e807a7fcd635fbc86f4e2">Portage::PRISM</a>, <a class="el" href="namespacePortage.html#a5f4ff6a944b45b72c32db1338353486ba38c809db2a35ad71a324ff276b638b13">Portage::PYRAMID</a>, <a class="el" href="namespacePortage.html#a5f4ff6a944b45b72c32db1338353486baddabca318743aed3bb7778deec79fe24">Portage::HEX</a>, <a class="el" href="namespacePortage.html#a5f4ff6a944b45b72c32db1338353486ba4c2bbf4ab5152603f23e9d11f24c364e">Portage::POLYHEDRON</a></p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> cell_get_faces_and_dirs(<span class="keywordtype">int</span> <span class="keyword">const</span> cellid, std::vector&lt;int&gt; *cfaces,</div><div class="line">                             std::vector&lt;int&gt; *cfdirs) <span class="keyword">const</span>;</div></div><!-- fragment --><p>NOTE: The 'cfdirs' conveys the directions in which the faces are used by the cell. If the natural normal of the face points out of the cell, its direction should be returned as 1, if not, it should be returned as -1</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> cell_get_nodes(<span class="keywordtype">int</span> <span class="keyword">const</span> cellid, std::vector&lt;int&gt; *cnodes) <span class="keyword">const</span>;</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> cell_get_node_adj_cells(<span class="keywordtype">int</span> <span class="keyword">const</span> cellid, <a class="code" href="namespacePortage.html#a650a8718a706648846a2915b90612849">Portage::Entity_type</a> etype,</div><div class="line">                             std::vector&lt;int&gt; *adjcells) <span class="keyword">const</span>;</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> face_get_nodes(<span class="keywordtype">int</span> <span class="keyword">const</span> faceid, std::vector&lt;int&gt; *fnodes) <span class="keyword">const</span>;</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> <a class="code" href="classPortage_1_1AuxMeshTopology.html#a230262249728d2e17f3856b6fb266820">face_get_cells</a>(<span class="keywordtype">int</span> <span class="keyword">const</span> faceid, <a class="code" href="namespacePortage.html#a650a8718a706648846a2915b90612849">Portage::Entity_type</a> etype,</div><div class="line">                    std::vector&lt;int&gt; *fcells) <span class="keyword">const</span>;</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> node_get_cell_adj_nodes(<span class="keywordtype">int</span> <span class="keyword">const</span> nodeid, <a class="code" href="namespacePortage.html#a650a8718a706648846a2915b90612849">Portage::Entity_type</a> etype,</div><div class="line">                             std::vector&lt;int&gt; *adjnodes) <span class="keyword">const</span>;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> get_global_id(<span class="keywordtype">int</span> <span class="keyword">const</span> <span class="keywordtype">id</span>, <a class="code" href="namespacePortage.html#a762e851d5a6ada63ea496d767679cffb">Entity_kind</a> <span class="keyword">const</span> kind) <span class="keyword">const</span>;</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keywordtype">long</span> D&gt;</div><div class="line"><span class="keywordtype">void</span> node_get_coordinates(<span class="keywordtype">int</span> <span class="keyword">const</span> nodeid, <a class="code" href="classPortage_1_1Point.html">Portage::Point&lt;D&gt;</a> *pp) <span class="keyword">const</span>;</div></div><!-- fragment --><p> ******************************** NOTE ***********************************</p>
<p>THIS IS AN INCOMPLETE CLASS DESIGNED TO BE USED IN A 'CRTP' (CURIOUSLY RECURRING TEMPLATE PATTERN) DESIGN ALONG WITH THE BASICMESH CLASS TO PROVIDE A COMPLETE MESH CLASS (See <a href="https://en.m.wikipedia.org/wiki/Curiously_recurring_template_pattern">https://en.m.wikipedia.org/wiki/Curiously_recurring_template_pattern</a>)</p>
<p>So, If one is writing a mesh wrapper class called <code>MY_MESH_WRAPPER</code>, it is declared like so</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>MY_MESH_WRAPPER : <span class="keyword">public</span> <a class="code" href="namespaceAuxMeshTopology.html">AuxMeshTopology</a>&lt;MY_MESH_WRAPPER&gt;</div><div class="line">{......}</div></div><!-- fragment --><p> and it will automatically have the methods of the <a class="el" href="classPortage_1_1AuxMeshTopology.html">AuxMeshTopology</a> class.</p>
<p>NOTE THAT THIS CLASS IS NOT DESIGNED TO EVER BE INSTANTIATED DIRECTLY</p>
<hr/>
 </div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a020e994323b94fbbed00f82e34560ba1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BasicMesh&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPortage_1_1AuxMeshTopology.html">Portage::AuxMeshTopology</a>&lt; BasicMesh &gt;::<a class="el" href="classPortage_1_1AuxMeshTopology.html">AuxMeshTopology</a> </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>request_sides</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>request_wedges</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>request_corners</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor indicating which entities are wanted. </p>
<p>It is possible to request none of the auxiliary entities so that one can instantiate a version of a derived class with the auxiliary entities or without (to save memory) </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="af43e0c21654b9c35d04f136325dfd5b0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BasicMesh&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacePortage.html#a5798f2be664fd95e54414f8aca5e3282">counting_iterator</a> <a class="el" href="classPortage_1_1AuxMeshTopology.html">Portage::AuxMeshTopology</a>&lt; BasicMesh &gt;::begin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacePortage.html#a762e851d5a6ada63ea496d767679cffb">Entity_kind</a> const&#160;</td>
          <td class="paramname"><em>entity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacePortage.html#a650a8718a706648846a2915b90612849">Entity_type</a> const&#160;</td>
          <td class="paramname"><em>etype</em> = <code>Entity_type::ALL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Iterators on mesh entity - begin. </p>

</div>
</div>
<a class="anchor" id="a245b18dcd54213270f3b28d84a1ab0d0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BasicMesh&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classPortage_1_1AuxMeshTopology.html">Portage::AuxMeshTopology</a>&lt; BasicMesh &gt;::build_aux_entities </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a827d5d76a49f65ad11b03e899fee0bef"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BasicMesh&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classPortage_1_1AuxMeshTopology.html">Portage::AuxMeshTopology</a>&lt; BasicMesh &gt;::ccw </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPortage_1_1Point.html">Point</a>&lt; 2 &gt; const &amp;&#160;</td>
          <td class="paramname"><em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPortage_1_1Point.html">Point</a>&lt; 2 &gt; const &amp;&#160;</td>
          <td class="paramname"><em>p2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPortage_1_1Point.html">Point</a>&lt; 2 &gt; const &amp;&#160;</td>
          <td class="paramname"><em>p3</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns true if the three 2D points (p1, p2, p3) are a counter-clockwise turn, otherwise returns false (corresponding to clockwise or collinear) </p>

</div>
</div>
<a class="anchor" id="a6be1d0af72ed2cb14eaff3d3f3725856"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BasicMesh&gt; </div>
<div class="memtemplate">
template&lt;long D&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classPortage_1_1AuxMeshTopology.html">Portage::AuxMeshTopology</a>&lt; BasicMesh &gt;::cell_centroid </td>
          <td>(</td>
          <td class="paramtype">int const&#160;</td>
          <td class="paramname"><em>cellid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPortage_1_1Point.html">Point</a>&lt; D &gt; *&#160;</td>
          <td class="paramname"><em>ccen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Centroid of a cell. </p>

</div>
</div>
<a class="anchor" id="ab43cbdf56afaa72d8b346835495184c2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BasicMesh &gt; </div>
<div class="memtemplate">
template&lt;long D&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classPortage_1_1AuxMeshTopology.html">Portage::AuxMeshTopology</a>&lt; BasicMesh &gt;::cell_get_coordinates </td>
          <td>(</td>
          <td class="paramtype">int const&#160;</td>
          <td class="paramname"><em>cellid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classPortage_1_1Point.html">Point</a>&lt; D &gt;&gt; *&#160;</td>
          <td class="paramname"><em>pplist</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Coordinates of nodes of cell. </p>
<p>coords of nodes of a cell </p>

</div>
</div>
<a class="anchor" id="ace0177f9c1529cd05c2894fc53bd03ec"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BasicMesh&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classPortage_1_1AuxMeshTopology.html">Portage::AuxMeshTopology</a>&lt; BasicMesh &gt;::cell_get_corner_at_node </td>
          <td>(</td>
          <td class="paramtype">int const&#160;</td>
          <td class="paramname"><em>cellid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int const&#160;</td>
          <td class="paramname"><em>nodeid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a cell's corner at a particular node of the cell. </p>

</div>
</div>
<a class="anchor" id="a93f5f891f5556fdc48c0cbd639e82f54"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BasicMesh&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classPortage_1_1AuxMeshTopology.html">Portage::AuxMeshTopology</a>&lt; BasicMesh &gt;::cell_get_corners </td>
          <td>(</td>
          <td class="paramtype">int const&#160;</td>
          <td class="paramname"><em>cellid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int &gt; *&#160;</td>
          <td class="paramname"><em>cornerids</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get corners in a cell. </p>

</div>
</div>
<a class="anchor" id="a67af8f0fa78afa7001b34f6722290a7b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BasicMesh&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classPortage_1_1AuxMeshTopology.html">Portage::AuxMeshTopology</a>&lt; BasicMesh &gt;::cell_get_sides </td>
          <td>(</td>
          <td class="paramtype">int const&#160;</td>
          <td class="paramname"><em>cellid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int &gt; *&#160;</td>
          <td class="paramname"><em>csides</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get all the sides of a cell. </p>

</div>
</div>
<a class="anchor" id="ad0455fd7775ee46a9a48fb834e4f73c4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BasicMesh&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classPortage_1_1AuxMeshTopology.html">Portage::AuxMeshTopology</a>&lt; BasicMesh &gt;::cell_get_wedges </td>
          <td>(</td>
          <td class="paramtype">int const&#160;</td>
          <td class="paramname"><em>cellid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int &gt; *&#160;</td>
          <td class="paramname"><em>wedgeids</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get all the wedges in a cell. </p>

</div>
</div>
<a class="anchor" id="a15ed249e53a5d560d3120fd7007ccf57"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BasicMesh&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="classPortage_1_1AuxMeshTopology.html">Portage::AuxMeshTopology</a>&lt; BasicMesh &gt;::cell_volume </td>
          <td>(</td>
          <td class="paramtype">int const&#160;</td>
          <td class="paramname"><em>cellid</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Volume of a cell. </p>

</div>
</div>
<a class="anchor" id="a7eddb95eaed6deea04342beb709498bf"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BasicMesh&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classPortage_1_1Point.html">Point</a>&lt;2&gt; &gt; <a class="el" href="classPortage_1_1AuxMeshTopology.html">Portage::AuxMeshTopology</a>&lt; BasicMesh &gt;::cellToXY </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>cellID</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="aa3631d51c16a3ed0af0bbc66461d968a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BasicMesh&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classPortage_1_1AuxMeshTopology.html">Portage::AuxMeshTopology</a>&lt; BasicMesh &gt;::corner_get_cell </td>
          <td>(</td>
          <td class="paramtype">int const&#160;</td>
          <td class="paramname"><em>cornerid</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get cell of corner. </p>

</div>
</div>
<a class="anchor" id="ad31237dd7201ce17d96ebe7afc27bdf6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BasicMesh&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classPortage_1_1AuxMeshTopology.html">Portage::AuxMeshTopology</a>&lt; BasicMesh &gt;::corner_get_node </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>cornerid</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get node of corner. </p>

</div>
</div>
<a class="anchor" id="acaafd2587004e8239ec8392de6a31e12"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BasicMesh&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classPortage_1_1AuxMeshTopology.html">Portage::AuxMeshTopology</a>&lt; BasicMesh &gt;::corner_get_wedges </td>
          <td>(</td>
          <td class="paramtype">int const&#160;</td>
          <td class="paramname"><em>cornerid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int &gt; *&#160;</td>
          <td class="paramname"><em>wedgeids</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get wedges of a corner. </p>

</div>
</div>
<a class="anchor" id="a6f12e9e2bcbee63d12a69c432db76391"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BasicMesh&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="classPortage_1_1AuxMeshTopology.html">Portage::AuxMeshTopology</a>&lt; BasicMesh &gt;::corner_volume </td>
          <td>(</td>
          <td class="paramtype">int const&#160;</td>
          <td class="paramname"><em>cornerid</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Volume of a corner. </p>

</div>
</div>
<a class="anchor" id="a5f535d17b2e4954f595f337e4fb8515b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BasicMesh&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classPortage_1_1AuxMeshTopology.html">Portage::AuxMeshTopology</a>&lt; BasicMesh &gt;::decompose_cell_into_tets </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>cellid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::array&lt; <a class="el" href="classPortage_1_1Point.html">Portage::Point</a>&lt; 3 &gt;, 4 &gt;&gt; *&#160;</td>
          <td class="paramname"><em>tcoords</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>planar_hex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the simplest possible decomposition of a 3D cell into tets. </p>

</div>
</div>
<a class="anchor" id="aa553ac201acbcc2856a1b97fcb2c5edc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BasicMesh&gt; </div>
<div class="memtemplate">
template&lt;long D&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classPortage_1_1AuxMeshTopology.html">Portage::AuxMeshTopology</a>&lt; BasicMesh &gt;::dual_cell_centroid </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nodeid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPortage_1_1Point.html">Point</a>&lt; D &gt; *&#160;</td>
          <td class="paramname"><em>centroid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Centroid of a dual cell. </p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000031">Todo:</a></b></dt><dd>NOTE: THIS IS ASSUMED TO BE THE NODE COORDINATE BECAUSE THE NODAL VARIABLES LIVE THERE, BUT FOR DISTORTED GRIDS, THE NODE COORDINATE MAY NOT BE THE CENTROID OF THE DUAL CELL </dd></dl>

</div>
</div>
<a class="anchor" id="a2bd3333d1a55c902e74c8d2ac037d2c6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BasicMesh&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classPortage_1_1AuxMeshTopology.html">Portage::AuxMeshTopology</a>&lt; BasicMesh &gt;::dual_cell_get_coordinates </td>
          <td>(</td>
          <td class="paramtype">int const&#160;</td>
          <td class="paramname"><em>nodeid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classPortage_1_1Point.html">Point</a>&lt; 2 &gt;&gt; *&#160;</td>
          <td class="paramname"><em>pplist</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>2D version of coords of nodes of a dual cell </p>

</div>
</div>
<a class="anchor" id="afbd99a988c1b4098b1bf205844302ee4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BasicMesh&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classPortage_1_1AuxMeshTopology.html">Portage::AuxMeshTopology</a>&lt; BasicMesh &gt;::dual_cell_get_coordinates </td>
          <td>(</td>
          <td class="paramtype">int const&#160;</td>
          <td class="paramname"><em>nodeid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classPortage_1_1Point.html">Point</a>&lt; 3 &gt;&gt; *&#160;</td>
          <td class="paramname"><em>pplist</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>3D version of coords of nodes of a dual cell </p>

</div>
</div>
<a class="anchor" id="a943d4e2b5e2cb865d3479040d4cb032d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BasicMesh&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classPortage_1_1AuxMeshTopology.html">Portage::AuxMeshTopology</a>&lt; BasicMesh &gt;::dual_cell_get_node_adj_cells </td>
          <td>(</td>
          <td class="paramtype">int const&#160;</td>
          <td class="paramname"><em>nodeid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacePortage.html#a650a8718a706648846a2915b90612849">Entity_type</a> const&#160;</td>
          <td class="paramname"><em>ptype</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int &gt; *&#160;</td>
          <td class="paramname"><em>adjnodes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get adjacent "dual cells" of a given "dual cell". </p>

</div>
</div>
<a class="anchor" id="a313c9f2e0255507a4c3943feaebdf1ba"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BasicMesh&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="classPortage_1_1AuxMeshTopology.html">Portage::AuxMeshTopology</a>&lt; BasicMesh &gt;::dual_cell_volume </td>
          <td>(</td>
          <td class="paramtype">int const&#160;</td>
          <td class="paramname"><em>nodeid</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the volume of dual cell by finding the corners that attach to the node. </p>

</div>
</div>
<a class="anchor" id="a8614b63a071dae828055ee89ea925d0c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BasicMesh&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classPortage_1_1AuxMeshTopology.html">Portage::AuxMeshTopology</a>&lt; BasicMesh &gt;::dual_wedges_get_coordinates </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nodeid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::array&lt; <a class="el" href="classPortage_1_1Point.html">Point</a>&lt; 3 &gt;, 4 &gt;&gt; *&#160;</td>
          <td class="paramname"><em>wcoords</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a82379618ad2cd57f3362a26762eabe60"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BasicMesh&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacePortage.html#a5798f2be664fd95e54414f8aca5e3282">counting_iterator</a> <a class="el" href="classPortage_1_1AuxMeshTopology.html">Portage::AuxMeshTopology</a>&lt; BasicMesh &gt;::end </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacePortage.html#a762e851d5a6ada63ea496d767679cffb">Entity_kind</a> const&#160;</td>
          <td class="paramname"><em>entity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacePortage.html#a650a8718a706648846a2915b90612849">Entity_type</a> const&#160;</td>
          <td class="paramname"><em>etype</em> = <code>Entity_type::ALL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Iterator on mesh entity - end. </p>

</div>
</div>
<a class="anchor" id="ab0d115f18705de06201687c129d6b6a2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BasicMesh&gt; </div>
<div class="memtemplate">
template&lt;long D&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classPortage_1_1AuxMeshTopology.html">Portage::AuxMeshTopology</a>&lt; BasicMesh &gt;::face_centroid </td>
          <td>(</td>
          <td class="paramtype">int const&#160;</td>
          <td class="paramname"><em>faceid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPortage_1_1Point.html">Point</a>&lt; D &gt; *&#160;</td>
          <td class="paramname"><em>fcen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Centroid of a face. </p>

</div>
</div>
<a class="anchor" id="a230262249728d2e17f3856b6fb266820"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BasicMesh&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classPortage_1_1AuxMeshTopology.html">Portage::AuxMeshTopology</a>&lt; BasicMesh &gt;::face_get_cells </td>
          <td>(</td>
          <td class="paramtype">int const&#160;</td>
          <td class="paramname"><em>faceid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacePortage.html#a650a8718a706648846a2915b90612849">Entity_type</a> const&#160;</td>
          <td class="paramname"><em>etype</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int &gt; *&#160;</td>
          <td class="paramname"><em>cells</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get cells of given Entity_type connected to face (in no particular order) </p>

</div>
</div>
<a class="anchor" id="a23fef51fa96d7264539a1887b8a6979a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BasicMesh&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classPortage_1_1AuxMeshTopology.html">Portage::AuxMeshTopology</a>&lt; BasicMesh &gt;::node_get_corners </td>
          <td>(</td>
          <td class="paramtype">int const&#160;</td>
          <td class="paramname"><em>nodeid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacePortage.html#a650a8718a706648846a2915b90612849">Entity_type</a> const&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int &gt; *&#160;</td>
          <td class="paramname"><em>cornerids</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get corners connected to a node. </p>

</div>
</div>
<a class="anchor" id="ae8d18194e614c90d14f3db7fef560061"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BasicMesh&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classPortage_1_1AuxMeshTopology.html">Portage::AuxMeshTopology</a>&lt; BasicMesh &gt;::node_get_wedges </td>
          <td>(</td>
          <td class="paramtype">int const&#160;</td>
          <td class="paramname"><em>nodeid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacePortage.html#a650a8718a706648846a2915b90612849">Entity_type</a> const&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int &gt; *&#160;</td>
          <td class="paramname"><em>wedgeids</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get wedges at a node. </p>

</div>
</div>
<a class="anchor" id="a72a7e33a70f9b88f974a377858e63f32"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BasicMesh&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classPortage_1_1AuxMeshTopology.html">Portage::AuxMeshTopology</a>&lt; BasicMesh &gt;::num_entities </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacePortage.html#a762e851d5a6ada63ea496d767679cffb">Entity_kind</a> const&#160;</td>
          <td class="paramname"><em>entity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacePortage.html#a650a8718a706648846a2915b90612849">Entity_type</a> const&#160;</td>
          <td class="paramname"><em>etype</em> = <code>Entity_type::ALL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Number of items of given entity. </p>

</div>
</div>
<a class="anchor" id="aa5c047de431dc1269c6defca71476147"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BasicMesh&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classPortage_1_1AuxMeshTopology.html">Portage::AuxMeshTopology</a>&lt; BasicMesh &gt;::num_ghost_corners </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Number of ghost corners in the mesh. </p>

</div>
</div>
<a class="anchor" id="ad9bb2bcd54b0d744d8a4082b65863534"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BasicMesh&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classPortage_1_1AuxMeshTopology.html">Portage::AuxMeshTopology</a>&lt; BasicMesh &gt;::num_ghost_sides </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Number of ghost sides in the mesh. </p>

</div>
</div>
<a class="anchor" id="a0c284523f9253c045d4c4652df0fdde0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BasicMesh&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classPortage_1_1AuxMeshTopology.html">Portage::AuxMeshTopology</a>&lt; BasicMesh &gt;::num_ghost_wedges </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Number of ghost wedges in the mesh. </p>

</div>
</div>
<a class="anchor" id="a0d5c48ae3a2d5ce6704a0ee5b17bfe1b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BasicMesh&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classPortage_1_1AuxMeshTopology.html">Portage::AuxMeshTopology</a>&lt; BasicMesh &gt;::num_owned_corners </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Number of owned corners in the mesh. </p>

</div>
</div>
<a class="anchor" id="a30d2dfa1c20c71145fe898b1529b21d7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BasicMesh&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classPortage_1_1AuxMeshTopology.html">Portage::AuxMeshTopology</a>&lt; BasicMesh &gt;::num_owned_sides </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Number of owned sides in the mesh. </p>

</div>
</div>
<a class="anchor" id="ae022c6b946032ed1d50d0b7957b483a2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BasicMesh&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classPortage_1_1AuxMeshTopology.html">Portage::AuxMeshTopology</a>&lt; BasicMesh &gt;::num_owned_wedges </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Number of owned wedges in the mesh. </p>

</div>
</div>
<a class="anchor" id="a10c5bf35b4c490316468ca7251d2a2b4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BasicMesh&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classPortage_1_1AuxMeshTopology.html">Portage::AuxMeshTopology</a>&lt; BasicMesh &gt;::on_exterior_boundary </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacePortage.html#a762e851d5a6ada63ea496d767679cffb">Entity_kind</a> const&#160;</td>
          <td class="paramname"><em>entity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int const&#160;</td>
          <td class="paramname"><em>entity_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>if entity is on exterior boundary </p>

</div>
</div>
<a class="anchor" id="a00c603b05fea6a12b1ba7f1f08598d77"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BasicMesh&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classPortage_1_1AuxMeshTopology.html">Portage::AuxMeshTopology</a>&lt; BasicMesh &gt;::order_wedges_ccw </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; int &gt; *&#160;</td>
          <td class="paramname"><em>wedgeids</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Order wedges around a node in ccw manner. </p>

</div>
</div>
<a class="anchor" id="af1f5bca2e914e77ed0855b31a2ead164"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BasicMesh&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classPortage_1_1AuxMeshTopology.html">Portage::AuxMeshTopology</a>&lt; BasicMesh &gt;::side_get_cell </td>
          <td>(</td>
          <td class="paramtype">int const&#160;</td>
          <td class="paramname"><em>sideid</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Cell of side. </p>

</div>
</div>
<a class="anchor" id="a4a2da0d50dc07ccf05e661e79e84310c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BasicMesh &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classPortage_1_1AuxMeshTopology.html">Portage::AuxMeshTopology</a>&lt; BasicMesh &gt;::side_get_coordinates </td>
          <td>(</td>
          <td class="paramtype">int const&#160;</td>
          <td class="paramname"><em>sideid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::array&lt; <a class="el" href="classPortage_1_1Point.html">Point</a>&lt; 3 &gt;, 4 &gt; *&#160;</td>
          <td class="paramname"><em>scoords</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>posvol_order</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>side coordinates in 3D </p>
<p>Get coordinates of side in 3D</p>
<p>If posvol_order = true, then the coordinates will be returned in an order that will result in a positive volume (in 3D this assumes that the computation for volume is done as (V01 x V02).V03 where V0k is a vector from coordinate 0 to coordinate k of the tet). If posvol_order is false, the coordinates will be returned in a fixed order - in 3D, this is node point 0, node point 1, face center, cell center. By default the coordinates are returned in the natural order (posvol_order = false) </p>

</div>
</div>
<a class="anchor" id="ae78e6ebc7ae90a5d22671e4893a562a7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BasicMesh &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classPortage_1_1AuxMeshTopology.html">Portage::AuxMeshTopology</a>&lt; BasicMesh &gt;::side_get_coordinates </td>
          <td>(</td>
          <td class="paramtype">int const&#160;</td>
          <td class="paramname"><em>sideid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::array&lt; <a class="el" href="classPortage_1_1Point.html">Point</a>&lt; 2 &gt;, 3 &gt; *&#160;</td>
          <td class="paramname"><em>scoords</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>posvol_order</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>side coordinates in 2D </p>
<p>Get coordinates of side in 2D</p>
<p>If posvol_order = true, then the coordinates will be returned in an order that will result in a positive area (in 2D this assumes that the computation for area is done as (V01 x V02).V03 where V0k is a vector from coordinate 0 to coordinate k of the tri). If posvol_order is false, the coordinates will be returned in a fixed order - in 2D, this is node point 0, node point 1, cell center. By default the coordinates are returned in the natural order (posvol_order = false) </p>

</div>
</div>
<a class="anchor" id="a99f30c7d9ebaecdc55d73ca191093641"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BasicMesh &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classPortage_1_1AuxMeshTopology.html">Portage::AuxMeshTopology</a>&lt; BasicMesh &gt;::side_get_coordinates </td>
          <td>(</td>
          <td class="paramtype">int const&#160;</td>
          <td class="paramname"><em>sideid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::array&lt; <a class="el" href="classPortage_1_1Point.html">Point</a>&lt; 1 &gt;, 2 &gt; *&#160;</td>
          <td class="paramname"><em>scoords</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>posvol_order</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>side coordinates in 1D </p>
<p>Get coordinates of side in 1D</p>
<p>If posvol_order = true, then the coordinates will be returned in an order that will result in a positive length. If posvol_order is false, the coordinates will be returned in a fixed order - in 1D, this is node point and cell center. By default the coordinates are returned in the natural order (posvol_order = false) </p>

</div>
</div>
<a class="anchor" id="ad27b0b53dec4105ad4eb5a333e298349"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BasicMesh&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classPortage_1_1AuxMeshTopology.html">Portage::AuxMeshTopology</a>&lt; BasicMesh &gt;::side_get_face </td>
          <td>(</td>
          <td class="paramtype">int const&#160;</td>
          <td class="paramname"><em>sideid</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Face of side. </p>

</div>
</div>
<a class="anchor" id="ae2f47c3477cdae0b4ab1122d0e36c2e0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BasicMesh&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classPortage_1_1AuxMeshTopology.html">Portage::AuxMeshTopology</a>&lt; BasicMesh &gt;::side_get_node </td>
          <td>(</td>
          <td class="paramtype">int const&#160;</td>
          <td class="paramname"><em>sideid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int const&#160;</td>
          <td class="paramname"><em>inode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Node of a side</p>
<p>Each side is tied to two mesh nodes in 2D and 3D and inode = 0 or 1 indicates which one to return. In 1D, the same node is returned whether inode = 0 or 1. In 2D and 3D, the node ordering is such that node 0, node 1 and the cell centroid form a positive area triangle and in 3D, node 0, node 1, the face centroid and cell centroid form a positive volume tet. </p>

</div>
</div>
<a class="anchor" id="a874888cd2685266bd2c0a06b315b2d8e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BasicMesh&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classPortage_1_1AuxMeshTopology.html">Portage::AuxMeshTopology</a>&lt; BasicMesh &gt;::side_get_opposite_side </td>
          <td>(</td>
          <td class="paramtype">int const&#160;</td>
          <td class="paramname"><em>sideid</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Opposite side in neighboring cell of a side.</p>
<p>The two sides share facet 0 of wedge comprised of nodes 0,1 of the common edge and center point of the common face in 3D, and nodes 0,1 of the common edge in 2D. At boundaries, this routine returns -1 </p>

</div>
</div>
<a class="anchor" id="a7c0b77165a9f734eb6ee258e8837dd07"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BasicMesh&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classPortage_1_1AuxMeshTopology.html">Portage::AuxMeshTopology</a>&lt; BasicMesh &gt;::side_get_wedge </td>
          <td>(</td>
          <td class="paramtype">int const&#160;</td>
          <td class="paramname"><em>sideid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iwedge</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Wedge of side</p>
<p>Each side points to two wedges - iwedge (0, 1) indicates which one to return; the wedge returned will be consistent with the node returned by side_get_node. So, side_get_node(s,i) = wedge_get_node(side_get_wedge(s,i)) </p>

</div>
</div>
<a class="anchor" id="a1be9d032ebed72415e602371981999cd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BasicMesh&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="classPortage_1_1AuxMeshTopology.html">Portage::AuxMeshTopology</a>&lt; BasicMesh &gt;::side_volume </td>
          <td>(</td>
          <td class="paramtype">int const&#160;</td>
          <td class="paramname"><em>sideid</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Volume of a side. </p>

</div>
</div>
<a class="anchor" id="a1ae14f060ebdc46669277e7b415dcfec"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BasicMesh&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classPortage_1_1AuxMeshTopology.html">Portage::AuxMeshTopology</a>&lt; BasicMesh &gt;::sides_get_coordinates </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>cellID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::array&lt; <a class="el" href="classPortage_1_1Point.html">Point</a>&lt; 3 &gt;, 4 &gt;&gt; *&#160;</td>
          <td class="paramname"><em>scoords</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get coordinates of side in 3D. </p>

</div>
</div>
<a class="anchor" id="a7b463da92bd4cf6eb8b00a4627ad9638"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BasicMesh&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classPortage_1_1AuxMeshTopology.html">Portage::AuxMeshTopology</a>&lt; BasicMesh &gt;::wedge_get_adjacent_wedge </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>wedgeid</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>adjacent wedge along edge in the same cell.</p>
<p>The two wedges share facet 1 of wedge comprised of edge center, face center and zone center in 3D, and node and zone center in 2D </p>

</div>
</div>
<a class="anchor" id="a6e7eb658889fd89583c2813172cef6df"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BasicMesh&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classPortage_1_1AuxMeshTopology.html">Portage::AuxMeshTopology</a>&lt; BasicMesh &gt;::wedge_get_cell </td>
          <td>(</td>
          <td class="paramtype">int const&#160;</td>
          <td class="paramname"><em>wedgeid</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Cell of wedge. </p>

</div>
</div>
<a class="anchor" id="a320775062103d12237875af6f56a16e9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BasicMesh &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classPortage_1_1AuxMeshTopology.html">Portage::AuxMeshTopology</a>&lt; BasicMesh &gt;::wedge_get_coordinates </td>
          <td>(</td>
          <td class="paramtype">int const&#160;</td>
          <td class="paramname"><em>wedgeid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::array&lt; <a class="el" href="classPortage_1_1Point.html">Point</a>&lt; 3 &gt;, 4 &gt; *&#160;</td>
          <td class="paramname"><em>wcoords</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>posvol_order</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wedge coordinates in 3D. </p>
<p>Get coordinates of wedge in 3D</p>
<p>If posvol_order = true, then the coordinates will be returned in an order that will result in a positive volume (in 3D this assumes that the computation for volume is done as (V01 x V02).V03 where V0k is a vector from coordinate 0 to coordinate k of the tet). If posvol_order is false, the coordinates will be returned in a fixed order - in 3D, this is node point, edge center, face center, cell center. By default the coordinates are returned in the natural order (posvol_order = false) </p>

</div>
</div>
<a class="anchor" id="ad6760ae4be65a18d40445a1e218d87d0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BasicMesh &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classPortage_1_1AuxMeshTopology.html">Portage::AuxMeshTopology</a>&lt; BasicMesh &gt;::wedge_get_coordinates </td>
          <td>(</td>
          <td class="paramtype">int const&#160;</td>
          <td class="paramname"><em>wedgeid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::array&lt; <a class="el" href="classPortage_1_1Point.html">Point</a>&lt; 2 &gt;, 3 &gt; *&#160;</td>
          <td class="paramname"><em>wcoords</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>posvol_order</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wedge coordinates in 2D. </p>
<p>Get coordinates of wedge in 2D</p>
<p>If posvol_order = true, then the coordinates will be returned in an order that will result in a positive area (in 2D this assumes that the computation for area is done as (V01 x V02).V03 where V0k is a vector from coordinate 0 to coordinate k of the tri). If posvol_order is false, the coordinates will be returned in a fixed order - in 2D, this is node point, face center, cell center. By default the coordinates are returned in the natural order (posvol_order = false) </p>

</div>
</div>
<a class="anchor" id="a5cd146bd784301fa2778fb324dc3b6ac"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BasicMesh &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classPortage_1_1AuxMeshTopology.html">Portage::AuxMeshTopology</a>&lt; BasicMesh &gt;::wedge_get_coordinates </td>
          <td>(</td>
          <td class="paramtype">int const&#160;</td>
          <td class="paramname"><em>wedgeid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::array&lt; <a class="el" href="classPortage_1_1Point.html">Point</a>&lt; 1 &gt;, 2 &gt; *&#160;</td>
          <td class="paramname"><em>wcoords</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>posvol_order</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wedge coordinates in 1D. </p>
<p>Get coordinates of wedge in 1D</p>
<p>If posvol_order = true, then the coordinates will be returned in an order that will result in a positive length. If posvol_order is false, the coordinates will be returned in a fixed order - in 1D, this is node point and cell center. By default the coordinates are returned in the natural order (posvol_order = false) </p>

</div>
</div>
<a class="anchor" id="a8124cedabe156104c4f76dd5e418bb29"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BasicMesh&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classPortage_1_1AuxMeshTopology.html">Portage::AuxMeshTopology</a>&lt; BasicMesh &gt;::wedge_get_corner </td>
          <td>(</td>
          <td class="paramtype">int const&#160;</td>
          <td class="paramname"><em>wedgeid</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Corner of a wedge. </p>

</div>
</div>
<a class="anchor" id="a009684aea2a5087b45c5f1a124e528df"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BasicMesh&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classPortage_1_1AuxMeshTopology.html">Portage::AuxMeshTopology</a>&lt; BasicMesh &gt;::wedge_get_face </td>
          <td>(</td>
          <td class="paramtype">int const&#160;</td>
          <td class="paramname"><em>wedgeid</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Face of wedge. </p>

</div>
</div>
<a class="anchor" id="a6b4caa22cb89665cf8339ff2ebcb26b9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BasicMesh&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classPortage_1_1AuxMeshTopology.html">Portage::AuxMeshTopology</a>&lt; BasicMesh &gt;::wedge_get_node </td>
          <td>(</td>
          <td class="paramtype">int const&#160;</td>
          <td class="paramname"><em>wedgeid</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>node of a wedge </p>

</div>
</div>
<a class="anchor" id="a447ed49682700d8fd4ce7899461bfdca"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BasicMesh&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classPortage_1_1AuxMeshTopology.html">Portage::AuxMeshTopology</a>&lt; BasicMesh &gt;::wedge_get_opposite_wedge </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>wedgeid</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Opposite wedge in neighboring cell of a wedge.</p>
<p>The two wedges share facet 0 of wedge comprised of the node, center point of the common edge and center point of the common face in 3D, and node and edge center in 2D. At boundaries, this routine returns -1 </p>

</div>
</div>
<a class="anchor" id="a756ba7c43fbc390ac3167e1dea284260"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BasicMesh&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classPortage_1_1AuxMeshTopology.html">Portage::AuxMeshTopology</a>&lt; BasicMesh &gt;::wedge_get_side </td>
          <td>(</td>
          <td class="paramtype">int const&#160;</td>
          <td class="paramname"><em>wedgeid</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Side of wedge. </p>

</div>
</div>
<a class="anchor" id="a2780b35f909befb2825800504bb4b86f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BasicMesh&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="classPortage_1_1AuxMeshTopology.html">Portage::AuxMeshTopology</a>&lt; BasicMesh &gt;::wedge_volume </td>
          <td>(</td>
          <td class="paramtype">int const&#160;</td>
          <td class="paramname"><em>wedgeid</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Volume of a wedge - half its side volume. </p>

</div>
</div>
<a class="anchor" id="add075adccbeaa188f85fab3db06f73e8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BasicMesh&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classPortage_1_1AuxMeshTopology.html">Portage::AuxMeshTopology</a>&lt; BasicMesh &gt;::wedges_get_coordinates </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>cellID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::array&lt; <a class="el" href="classPortage_1_1Point.html">Point</a>&lt; 3 &gt;, 4 &gt;&gt; *&#160;</td>
          <td class="paramname"><em>wcoords</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get coordinates of wedge in 3D. </p>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a class="anchor" id="ae3d64c4b8ca10e92cae57654e1a021b9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BasicMesh&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void build_sides_1D </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPortage_1_1AuxMeshTopology.html">AuxMeshTopology</a>&lt; BasicMesh &gt; &amp;&#160;</td>
          <td class="paramname"><em>mesh</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="aa7e5f2ed32d0f63e3fbf9586cf38a6c8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BasicMesh&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void build_sides_2D </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPortage_1_1AuxMeshTopology.html">AuxMeshTopology</a>&lt; BasicMesh &gt; &amp;&#160;</td>
          <td class="paramname"><em>mesh</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ad65c6b6888f43baabe341385246c9718"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BasicMesh&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void build_sides_3D </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPortage_1_1AuxMeshTopology.html">AuxMeshTopology</a>&lt; BasicMesh &gt; &amp;&#160;</td>
          <td class="paramname"><em>mesh</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/Users/l280837/code/portage-gh/src/wonton/mesh/<a class="el" href="AuxMeshTopology_8h_source.html">AuxMeshTopology.h</a></li>
</ul>
</div><!-- contents -->
<!--
This file is part of the Ristra portage project.
Please see the license file at the root of this repository, or at:
    https://github.com/laristra/portage/blob/master/LICENSE
-->
<!-- HTML footer for doxygen 1.8.8-->
<!-- start footer part -->
</div>
</div>
</div>
</div>
</div>
<!--<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address> -->
<footer id="footer" class="footer">
  <div class="container">
    <div class="row test-muted">
      <div class="footer-row col-md-6">Copyright &copy; 2016
	<a href="http://lanl.gov"> Los Alamos National Security, LLC</a>
	All Rights Reserved.
      </div>
      <div class="footer-row col-md-2">
	<a href="https://github.com/laristra/portage/blob/master/LICENSE">
	  BSD LICENSE
	</a>
      </div>
      <div class="footer-row col-md-2">
	LA-CC-16-084
      </div>
      <div class="footer-row col-md-1">
	<a href="mailto:portage@lanl.gov">
	  <i class="fa fa-envelope-o fa-2x"></i>
	</a>
      </div>
      <div class="footer-row col-md-1">
	<a href="https://github.com/laristra/portage">
	  <i class="fa fa-github fa-2x"></i>
	</a>
      </div>
    </div>
  </div>
</footer>
</body>
</html>
