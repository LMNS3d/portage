<!--
Copyright (c) 2016, Los Alamos National Security, LLC
All rights reserved.
Copyright 2016. Los Alamos National Security, LLC. This software was produced
under U.S. Government contract DE-AC52-06NA25396 for Los Alamos National
Laboratory (LANL), which is operated by Los Alamos National Security, LLC for
the U.S. Department of Energy. The U.S. Government has rights to use,
reproduce, and distribute this software.  NEITHER THE GOVERNMENT NOR LOS ALAMOS
NATIONAL SECURITY, LLC MAKES ANY WARRANTY, EXPRESS OR IMPLIED, OR ASSUMES ANY
LIABILITY FOR THE USE OF THIS SOFTWARE.  If software is modified to produce
derivative works, such modified software should be clearly marked, so as not to
confuse it with the version available from LANL.
Additionally, redistribution and use in source and binary forms, with or
without modification, are permitted provided that the following conditions are
met:
1. Redistributions of source code must retain the above copyright notice,
   this list of conditions and the following disclaimer.
2. Redistributions in binary form must reproduce the above copyright
   notice, this list of conditions and the following disclaimer in the
   documentation and/or other materials provided with the distribution.
3. Neither the name of Los Alamos National Security, LLC, Los Alamos
   National Laboratory, LANL, the U.S. Government, nor the names of its
   contributors may be used to endorse or promote products derived from this
   software without specific prior written permission.
THIS SOFTWARE IS PROVIDED BY LOS ALAMOS NATIONAL SECURITY, LLC AND
CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL LOS ALAMOS NATIONAL
SECURITY, LLC OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER
IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
POSSIBILITY OF SUCH DAMAGE.
-->
<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=edge"/>
    <!-- For Mobile Devices -->
    <meta name="viewport" content="width=device-width, initial-scale=1"/>
    <!-- Font stuff -->
    <link href='https://fonts.googleapis.com/css?family=Roboto+Slab' rel='stylesheet' type='text/css'/>
    <!-- Font Awesome -->
    <!--    <link rel="stylesheet" href="font-awesome-4.3.0/css/font-awesome.min.css"/> -->
    <script src="https://use.fontawesome.com/3dce4d8e65.js"></script>
    <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
    <meta name="generator" content="Doxygen 1.8.11"/>
    <script type="text/javascript" src="https://code.jquery.com/jquery-3.1.1.min.js"></script>
    <title>portage: Portage::Flecsi_Mesh_Wrapper Class Reference</title>
    <script type="text/javascript" src="dynsections.js"></script>
    <link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
    <link href="doxygen.css" rel="stylesheet" type="text/css" />
    <link href="customdoxygen.css" rel="stylesheet" type="text/css"/>
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css"/>
    <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js"></script>
    <script type="text/javascript" src="doxy-boot.js"></script>
  </head>
  <body>
    <nav class="navbar navbar-default" role="navigation">
      <div class="container">
        <div class="navbar-header">
          <a class="navbar-brand">portage 1.0.alpha</a>
        </div>
      </div>
    </nav>
    <div id="top"><!-- do not remove this div, it is closed by doxygen! -->
      <div class="content" id="content">
        <div class="container">
          <div class="row">
            <div class="col-sm-12 panel " style="padding-bottom: 15px;">
              <div style="margin-bottom: 15px;">
		<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="quickstart.html"><span>Quick&#160;Start</span></a></li>
      <li><a href="simple_mesh.html"><span>Example&#160;Use</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacePortage.html">Portage</a></li><li class="navelem"><a class="el" href="classPortage_1_1Flecsi__Mesh__Wrapper.html">Flecsi_Mesh_Wrapper</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classPortage_1_1Flecsi__Mesh__Wrapper-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Portage::Flecsi_Mesh_Wrapper Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><a class="el" href="classPortage_1_1Flecsi__Mesh__Wrapper.html" title="Flecsi_Mesh_Wrapper implements mesh methods for Flecsi. ">Flecsi_Mesh_Wrapper</a> implements mesh methods for Flecsi.  
 <a href="classPortage_1_1Flecsi__Mesh__Wrapper.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="flecsi__mesh__wrapper_8h_source.html">flecsi_mesh_wrapper.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a3968ab14a157ba93354defd2b8829275"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPortage_1_1Flecsi__Mesh__Wrapper.html#a3968ab14a157ba93354defd2b8829275">Flecsi_Mesh_Wrapper</a> (<a class="el" href="flecsi__mesh__wrapper_8h.html#ab742d3fd4b20e23606e9d39ca769f611">mesh_t</a> &amp;mesh)</td></tr>
<tr class="memdesc:a3968ab14a157ba93354defd2b8829275"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor.  <a href="#a3968ab14a157ba93354defd2b8829275">More...</a><br /></td></tr>
<tr class="separator:a3968ab14a157ba93354defd2b8829275"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3fc6ab945194a477baf758a39ec5c82"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPortage_1_1Flecsi__Mesh__Wrapper.html#aa3fc6ab945194a477baf758a39ec5c82">Flecsi_Mesh_Wrapper</a> (<a class="el" href="classPortage_1_1Flecsi__Mesh__Wrapper.html">Flecsi_Mesh_Wrapper</a> const &amp;inmesh)</td></tr>
<tr class="memdesc:aa3fc6ab945194a477baf758a39ec5c82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor.  <a href="#aa3fc6ab945194a477baf758a39ec5c82">More...</a><br /></td></tr>
<tr class="separator:aa3fc6ab945194a477baf758a39ec5c82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d533122a6dae133507ef338061793fb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPortage_1_1Flecsi__Mesh__Wrapper.html">Flecsi_Mesh_Wrapper</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPortage_1_1Flecsi__Mesh__Wrapper.html#a8d533122a6dae133507ef338061793fb">operator=</a> (<a class="el" href="classPortage_1_1Flecsi__Mesh__Wrapper.html">Flecsi_Mesh_Wrapper</a> const &amp;)=delete</td></tr>
<tr class="memdesc:a8d533122a6dae133507ef338061793fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment operator (disabled)  <a href="#a8d533122a6dae133507ef338061793fb">More...</a><br /></td></tr>
<tr class="separator:a8d533122a6dae133507ef338061793fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a5943c1d9f4d52ca505b40b28a304cb"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPortage_1_1Flecsi__Mesh__Wrapper.html#a6a5943c1d9f4d52ca505b40b28a304cb">~Flecsi_Mesh_Wrapper</a> ()</td></tr>
<tr class="memdesc:a6a5943c1d9f4d52ca505b40b28a304cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Empty destructor.  <a href="#a6a5943c1d9f4d52ca505b40b28a304cb">More...</a><br /></td></tr>
<tr class="separator:a6a5943c1d9f4d52ca505b40b28a304cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0e6e79b43ba1a5b03d2389dbf1c6317"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPortage_1_1Flecsi__Mesh__Wrapper.html#af0e6e79b43ba1a5b03d2389dbf1c6317">space_dimension</a> () const </td></tr>
<tr class="memdesc:af0e6e79b43ba1a5b03d2389dbf1c6317"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dimension of space or mesh points.  <a href="#af0e6e79b43ba1a5b03d2389dbf1c6317">More...</a><br /></td></tr>
<tr class="separator:af0e6e79b43ba1a5b03d2389dbf1c6317"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a420667c6fbf0a061236b6cfd93c042ed"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPortage_1_1Flecsi__Mesh__Wrapper.html#a420667c6fbf0a061236b6cfd93c042ed">cell_volume</a> (int const cellID) const </td></tr>
<tr class="memdesc:a420667c6fbf0a061236b6cfd93c042ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cell area/volume.  <a href="#a420667c6fbf0a061236b6cfd93c042ed">More...</a><br /></td></tr>
<tr class="separator:a420667c6fbf0a061236b6cfd93c042ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8963a443e72966373a60503b2ace3fc"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPortage_1_1Flecsi__Mesh__Wrapper.html#ac8963a443e72966373a60503b2ace3fc">dual_cell_volume</a> (int const nodeid) const </td></tr>
<tr class="memdesc:ac8963a443e72966373a60503b2ace3fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dual cell area/volume.  <a href="#ac8963a443e72966373a60503b2ace3fc">More...</a><br /></td></tr>
<tr class="separator:ac8963a443e72966373a60503b2ace3fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa922df7274dda27dd499e1b30def9be5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPortage_1_1Flecsi__Mesh__Wrapper.html#aa922df7274dda27dd499e1b30def9be5">num_owned_cells</a> () const </td></tr>
<tr class="memdesc:aa922df7274dda27dd499e1b30def9be5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of owned cells in the mesh.  <a href="#aa922df7274dda27dd499e1b30def9be5">More...</a><br /></td></tr>
<tr class="separator:aa922df7274dda27dd499e1b30def9be5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada2be83a48ee9e9e91ff46b9bc8d600d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPortage_1_1Flecsi__Mesh__Wrapper.html#ada2be83a48ee9e9e91ff46b9bc8d600d">num_owned_nodes</a> () const </td></tr>
<tr class="memdesc:ada2be83a48ee9e9e91ff46b9bc8d600d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of owned nodes in the mesh.  <a href="#ada2be83a48ee9e9e91ff46b9bc8d600d">More...</a><br /></td></tr>
<tr class="separator:ada2be83a48ee9e9e91ff46b9bc8d600d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbc606702094ec275d2f1100de05d124"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPortage_1_1Flecsi__Mesh__Wrapper.html#abbc606702094ec275d2f1100de05d124">num_owned_faces</a> () const </td></tr>
<tr class="memdesc:abbc606702094ec275d2f1100de05d124"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of owned faces in the mesh.  <a href="#abbc606702094ec275d2f1100de05d124">More...</a><br /></td></tr>
<tr class="separator:abbc606702094ec275d2f1100de05d124"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a243a74480861ec877eedb6a24c953736"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPortage_1_1Flecsi__Mesh__Wrapper.html#a243a74480861ec877eedb6a24c953736">num_ghost_cells</a> () const </td></tr>
<tr class="memdesc:a243a74480861ec877eedb6a24c953736"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of ghost cells in the mesh.  <a href="#a243a74480861ec877eedb6a24c953736">More...</a><br /></td></tr>
<tr class="separator:a243a74480861ec877eedb6a24c953736"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9875b7cb65fe13fc8b52a1e1ab1353ba"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPortage_1_1Flecsi__Mesh__Wrapper.html#a9875b7cb65fe13fc8b52a1e1ab1353ba">num_ghost_faces</a> () const </td></tr>
<tr class="memdesc:a9875b7cb65fe13fc8b52a1e1ab1353ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of ghost faces in the mesh.  <a href="#a9875b7cb65fe13fc8b52a1e1ab1353ba">More...</a><br /></td></tr>
<tr class="separator:a9875b7cb65fe13fc8b52a1e1ab1353ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab09f8baee178d83f1d9adb36c39e36e9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPortage_1_1Flecsi__Mesh__Wrapper.html#ab09f8baee178d83f1d9adb36c39e36e9">num_ghost_nodes</a> () const </td></tr>
<tr class="memdesc:ab09f8baee178d83f1d9adb36c39e36e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of ghost nodes in the mesh.  <a href="#ab09f8baee178d83f1d9adb36c39e36e9">More...</a><br /></td></tr>
<tr class="separator:ab09f8baee178d83f1d9adb36c39e36e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7bc1c1f9ebd6bba8aa8de2a4f01b72a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPortage_1_1Flecsi__Mesh__Wrapper.html#ad7bc1c1f9ebd6bba8aa8de2a4f01b72a">num_entities</a> (<a class="el" href="namespacePortage.html#a762e851d5a6ada63ea496d767679cffb">Entity_kind</a> const entity, <a class="el" href="namespacePortage.html#a650a8718a706648846a2915b90612849">Entity_type</a> const etype=Entity_type::ALL) const </td></tr>
<tr class="memdesc:ad7bc1c1f9ebd6bba8aa8de2a4f01b72a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of items of given entity.  <a href="#ad7bc1c1f9ebd6bba8aa8de2a4f01b72a">More...</a><br /></td></tr>
<tr class="separator:ad7bc1c1f9ebd6bba8aa8de2a4f01b72a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c7987115376facf6cfdbf1111c94122"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacePortage.html#a9ad5b714018a06f725ef8f93b70fabe7">counting_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPortage_1_1Flecsi__Mesh__Wrapper.html#a5c7987115376facf6cfdbf1111c94122">begin</a> (<a class="el" href="namespacePortage.html#a762e851d5a6ada63ea496d767679cffb">Entity_kind</a> const entity, <a class="el" href="namespacePortage.html#a650a8718a706648846a2915b90612849">Entity_type</a> const etype=Entity_type::ALL) const </td></tr>
<tr class="memdesc:a5c7987115376facf6cfdbf1111c94122"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterators on mesh entity - begin.  <a href="#a5c7987115376facf6cfdbf1111c94122">More...</a><br /></td></tr>
<tr class="separator:a5c7987115376facf6cfdbf1111c94122"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5eec2902830c76031fc7b1a3cdea51a1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacePortage.html#a9ad5b714018a06f725ef8f93b70fabe7">counting_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPortage_1_1Flecsi__Mesh__Wrapper.html#a5eec2902830c76031fc7b1a3cdea51a1">end</a> (<a class="el" href="namespacePortage.html#a762e851d5a6ada63ea496d767679cffb">Entity_kind</a> const entity, <a class="el" href="namespacePortage.html#a650a8718a706648846a2915b90612849">Entity_type</a> const etype=Entity_type::ALL) const </td></tr>
<tr class="memdesc:a5eec2902830c76031fc7b1a3cdea51a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterator on mesh entity - end.  <a href="#a5eec2902830c76031fc7b1a3cdea51a1">More...</a><br /></td></tr>
<tr class="separator:a5eec2902830c76031fc7b1a3cdea51a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e87b76dbd6397d966c733425f3f06e8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPortage_1_1Flecsi__Mesh__Wrapper.html#a1e87b76dbd6397d966c733425f3f06e8">cell_get_nodes</a> (int cellid, std::vector&lt; int &gt; *nodes) const </td></tr>
<tr class="memdesc:a1e87b76dbd6397d966c733425f3f06e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get list of nodes for a cell.  <a href="#a1e87b76dbd6397d966c733425f3f06e8">More...</a><br /></td></tr>
<tr class="separator:a1e87b76dbd6397d966c733425f3f06e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab95a5cfaee2d9bbc2ad1d4a10bb5f367"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPortage_1_1Flecsi__Mesh__Wrapper.html#ab95a5cfaee2d9bbc2ad1d4a10bb5f367">cell_get_faces_and_dirs</a> (int const cellid, std::vector&lt; int &gt; *cfaces, std::vector&lt; int &gt; *cfdirs) const </td></tr>
<tr class="memdesc:ab95a5cfaee2d9bbc2ad1d4a10bb5f367"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get cell faces and the directions in which they are used.  <a href="#ab95a5cfaee2d9bbc2ad1d4a10bb5f367">More...</a><br /></td></tr>
<tr class="separator:ab95a5cfaee2d9bbc2ad1d4a10bb5f367"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a810e4400b333b9aa03c603fdf81d30a5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPortage_1_1Flecsi__Mesh__Wrapper.html#a810e4400b333b9aa03c603fdf81d30a5">face_get_nodes</a> (int const faceid, std::vector&lt; int &gt; *fnodes) const </td></tr>
<tr class="memdesc:a810e4400b333b9aa03c603fdf81d30a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get nodes of a face.  <a href="#a810e4400b333b9aa03c603fdf81d30a5">More...</a><br /></td></tr>
<tr class="separator:a810e4400b333b9aa03c603fdf81d30a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9f8430636c53f74ba452222e1555196"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPortage_1_1Flecsi__Mesh__Wrapper.html#ab9f8430636c53f74ba452222e1555196">cell_get_node_adj_cells</a> (int const cellid, <a class="el" href="namespacePortage.html#a650a8718a706648846a2915b90612849">Entity_type</a> const ptype, std::vector&lt; int &gt; *adjcells) const </td></tr>
<tr class="memdesc:ab9f8430636c53f74ba452222e1555196"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get node connected neighbors of cell.  <a href="#ab9f8430636c53f74ba452222e1555196">More...</a><br /></td></tr>
<tr class="separator:ab9f8430636c53f74ba452222e1555196"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ca2c3901e264cee5b9f64ba701f3554"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPortage_1_1Flecsi__Mesh__Wrapper.html#a7ca2c3901e264cee5b9f64ba701f3554">node_get_cell_adj_nodes</a> (int const nodeid, <a class="el" href="namespacePortage.html#a650a8718a706648846a2915b90612849">Entity_type</a> const ptype, std::vector&lt; int &gt; *adjnodes) const </td></tr>
<tr class="memdesc:a7ca2c3901e264cee5b9f64ba701f3554"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get "adjacent" nodes of given node.  <a href="#a7ca2c3901e264cee5b9f64ba701f3554">More...</a><br /></td></tr>
<tr class="separator:a7ca2c3901e264cee5b9f64ba701f3554"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47b8c6fbaa3f2c1b3a9e07e33782ad93"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPortage_1_1Flecsi__Mesh__Wrapper.html#a47b8c6fbaa3f2c1b3a9e07e33782ad93">dual_cell_get_node_adj_cells</a> (int const nodeid, <a class="el" href="namespacePortage.html#a650a8718a706648846a2915b90612849">Entity_type</a> const ptype, std::vector&lt; int &gt; *adjnodes) const </td></tr>
<tr class="memdesc:a47b8c6fbaa3f2c1b3a9e07e33782ad93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get adjacent "dual cells" of a given "dual cell".  <a href="#a47b8c6fbaa3f2c1b3a9e07e33782ad93">More...</a><br /></td></tr>
<tr class="separator:a47b8c6fbaa3f2c1b3a9e07e33782ad93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab27331d45757a24db986172a27dfa47b"><td class="memTemplParams" colspan="2">template&lt;long D&gt; </td></tr>
<tr class="memitem:ab27331d45757a24db986172a27dfa47b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classPortage_1_1Flecsi__Mesh__Wrapper.html#ab27331d45757a24db986172a27dfa47b">node_get_coordinates</a> (int const nodeid, <a class="el" href="classPortage_1_1Point.html">Portage::Point</a>&lt; D &gt; *pp) const </td></tr>
<tr class="memdesc:ab27331d45757a24db986172a27dfa47b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Templated version of coords of a node.  <a href="#ab27331d45757a24db986172a27dfa47b">More...</a><br /></td></tr>
<tr class="separator:ab27331d45757a24db986172a27dfa47b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bcef35d48c6fcc9d9f4ab39adf0fa0e"><td class="memTemplParams" colspan="2">template&lt;long D&gt; </td></tr>
<tr class="memitem:a4bcef35d48c6fcc9d9f4ab39adf0fa0e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classPortage_1_1Flecsi__Mesh__Wrapper.html#a4bcef35d48c6fcc9d9f4ab39adf0fa0e">cell_get_coordinates</a> (int const cellid, std::vector&lt; <a class="el" href="classPortage_1_1Point.html">Portage::Point</a>&lt; D &gt;&gt; *pplist) const </td></tr>
<tr class="memdesc:a4bcef35d48c6fcc9d9f4ab39adf0fa0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Templated version of coodinates of the nodes of a cell.  <a href="#a4bcef35d48c6fcc9d9f4ab39adf0fa0e">More...</a><br /></td></tr>
<tr class="separator:a4bcef35d48c6fcc9d9f4ab39adf0fa0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6011a551dc74a57d28537399259926f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPortage_1_1Flecsi__Mesh__Wrapper.html#ac6011a551dc74a57d28537399259926f">dual_cell_get_coordinates</a> (int const nodeid, std::vector&lt; <a class="el" href="namespacePortage.html#a851c0332d789f5c3ca6c9ef50e375f25">Portage::Point2</a> &gt; *pplist) const </td></tr>
<tr class="memdesc:ac6011a551dc74a57d28537399259926f"><td class="mdescLeft">&#160;</td><td class="mdescRight">2D version of coords of nodes of a dual cell  <a href="#ac6011a551dc74a57d28537399259926f">More...</a><br /></td></tr>
<tr class="separator:ac6011a551dc74a57d28537399259926f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fa1fcd29bec351e056e65f024d563e7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPortage_1_1Flecsi__Mesh__Wrapper.html#a0fa1fcd29bec351e056e65f024d563e7">order_wedges_ccw</a> (std::vector&lt; int &gt; *wedgeids) const </td></tr>
<tr class="separator:a0fa1fcd29bec351e056e65f024d563e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7939f4b04c71f83a5a7fcf95c8ba1dba"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPortage_1_1Flecsi__Mesh__Wrapper.html#a7939f4b04c71f83a5a7fcf95c8ba1dba">ccw</a> (const <a class="el" href="namespacePortage.html#a851c0332d789f5c3ca6c9ef50e375f25">Portage::Point2</a> p1, const <a class="el" href="namespacePortage.html#a851c0332d789f5c3ca6c9ef50e375f25">Portage::Point2</a> p2, const <a class="el" href="namespacePortage.html#a851c0332d789f5c3ca6c9ef50e375f25">Portage::Point2</a> p3) const </td></tr>
<tr class="separator:a7939f4b04c71f83a5a7fcf95c8ba1dba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38922699ba1245c3a358ad2112447973"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="namespacePortage.html#a851c0332d789f5c3ca6c9ef50e375f25">Portage::Point2</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPortage_1_1Flecsi__Mesh__Wrapper.html#a38922699ba1245c3a358ad2112447973">cellToXY</a> (int const cellID) const </td></tr>
<tr class="separator:a38922699ba1245c3a358ad2112447973"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae53adcd1032b21c68b9edd78869c151c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPortage_1_1Flecsi__Mesh__Wrapper.html#ae53adcd1032b21c68b9edd78869c151c">wedges_get_coordinates</a> (int const cellID, std::vector&lt; std::array&lt; <a class="el" href="namespacePortage.html#a991ba1823c1528ffe149889e79fb4450">Portage::Point3</a>, 4 &gt;&gt; *wcoords) const </td></tr>
<tr class="separator:ae53adcd1032b21c68b9edd78869c151c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a144ce2ed51265dff13608f0fb16ec1c3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPortage_1_1Flecsi__Mesh__Wrapper.html#a144ce2ed51265dff13608f0fb16ec1c3">decompose_cell_into_tets</a> (int const cellID, std::vector&lt; std::array&lt; <a class="el" href="namespacePortage.html#a991ba1823c1528ffe149889e79fb4450">Portage::Point3</a>, 4 &gt;&gt; *tcoords, const bool planar_hex) const </td></tr>
<tr class="separator:a144ce2ed51265dff13608f0fb16ec1c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a792dfa8d09e9ed42f77e0b731d8883"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPortage_1_1Flecsi__Mesh__Wrapper.html#a7a792dfa8d09e9ed42f77e0b731d8883">dual_cell_get_coordinates</a> (int const nodeid, std::vector&lt; <a class="el" href="namespacePortage.html#a991ba1823c1528ffe149889e79fb4450">Portage::Point3</a> &gt; *pplist) const </td></tr>
<tr class="memdesc:a7a792dfa8d09e9ed42f77e0b731d8883"><td class="mdescLeft">&#160;</td><td class="mdescRight">3D version of coords of nodes of a dual cell  <a href="#a7a792dfa8d09e9ed42f77e0b731d8883">More...</a><br /></td></tr>
<tr class="separator:a7a792dfa8d09e9ed42f77e0b731d8883"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae157b4f064bc32db4f20eaed9c96223e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPortage_1_1Flecsi__Mesh__Wrapper.html#ae157b4f064bc32db4f20eaed9c96223e">dual_wedges_get_coordinates</a> (int const nodeID, std::vector&lt; std::array&lt; <a class="el" href="namespacePortage.html#a991ba1823c1528ffe149889e79fb4450">Portage::Point3</a>, 4 &gt;&gt; *wcoords) const </td></tr>
<tr class="separator:ae157b4f064bc32db4f20eaed9c96223e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28947e908619cf791f796bff12f647ea"><td class="memTemplParams" colspan="2">template&lt;long D&gt; </td></tr>
<tr class="memitem:a28947e908619cf791f796bff12f647ea"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classPortage_1_1Flecsi__Mesh__Wrapper.html#a28947e908619cf791f796bff12f647ea">cell_centroid</a> (int const cellid, <a class="el" href="classPortage_1_1Point.html">Point</a>&lt; D &gt; *centroid) const </td></tr>
<tr class="memdesc:a28947e908619cf791f796bff12f647ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Centroid of a cell.  <a href="#a28947e908619cf791f796bff12f647ea">More...</a><br /></td></tr>
<tr class="separator:a28947e908619cf791f796bff12f647ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3bff1ceb458fe85897c79764127657b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPortage_1_1Flecsi__Mesh__Wrapper.html#af3bff1ceb458fe85897c79764127657b">get_global_id</a> (int const id, <a class="el" href="namespacePortage.html#a762e851d5a6ada63ea496d767679cffb">Entity_kind</a> const kind) const </td></tr>
<tr class="memdesc:af3bff1ceb458fe85897c79764127657b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get global id.  <a href="#af3bff1ceb458fe85897c79764127657b">More...</a><br /></td></tr>
<tr class="separator:af3bff1ceb458fe85897c79764127657b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaaafd607470b22e89cdcf5902144e894"><td class="memTemplParams" colspan="2">template&lt;long D&gt; </td></tr>
<tr class="memitem:aaaafd607470b22e89cdcf5902144e894"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classPortage_1_1Flecsi__Mesh__Wrapper.html#aaaafd607470b22e89cdcf5902144e894">dual_cell_centroid</a> (int const nodeid, <a class="el" href="classPortage_1_1Point.html">Point</a>&lt; D &gt; *centroid) const </td></tr>
<tr class="memdesc:aaaafd607470b22e89cdcf5902144e894"><td class="mdescLeft">&#160;</td><td class="mdescRight">Centroid of a dual cell.  <a href="#aaaafd607470b22e89cdcf5902144e894">More...</a><br /></td></tr>
<tr class="separator:aaaafd607470b22e89cdcf5902144e894"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p><a class="el" href="classPortage_1_1Flecsi__Mesh__Wrapper.html" title="Flecsi_Mesh_Wrapper implements mesh methods for Flecsi. ">Flecsi_Mesh_Wrapper</a> implements mesh methods for Flecsi. </p>
<p><a class="el" href="classPortage_1_1Flecsi__Mesh__Wrapper.html" title="Flecsi_Mesh_Wrapper implements mesh methods for Flecsi. ">Flecsi_Mesh_Wrapper</a> implements methods required for <a class="el" href="namespacePortage.html">Portage</a> mesh queries for the Flecsi mesh infrastructure </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a3968ab14a157ba93354defd2b8829275"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Portage::Flecsi_Mesh_Wrapper::Flecsi_Mesh_Wrapper </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="flecsi__mesh__wrapper_8h.html#ab742d3fd4b20e23606e9d39ca769f611">mesh_t</a> &amp;&#160;</td>
          <td class="paramname"><em>mesh</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor. </p>

</div>
</div>
<a class="anchor" id="aa3fc6ab945194a477baf758a39ec5c82"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Portage::Flecsi_Mesh_Wrapper::Flecsi_Mesh_Wrapper </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPortage_1_1Flecsi__Mesh__Wrapper.html">Flecsi_Mesh_Wrapper</a> const &amp;&#160;</td>
          <td class="paramname"><em>inmesh</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy constructor. </p>

</div>
</div>
<a class="anchor" id="a6a5943c1d9f4d52ca505b40b28a304cb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Portage::Flecsi_Mesh_Wrapper::~Flecsi_Mesh_Wrapper </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Empty destructor. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a5c7987115376facf6cfdbf1111c94122"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacePortage.html#a9ad5b714018a06f725ef8f93b70fabe7">counting_iterator</a> Portage::Flecsi_Mesh_Wrapper::begin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacePortage.html#a762e851d5a6ada63ea496d767679cffb">Entity_kind</a> const&#160;</td>
          <td class="paramname"><em>entity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacePortage.html#a650a8718a706648846a2915b90612849">Entity_type</a> const&#160;</td>
          <td class="paramname"><em>etype</em> = <code>Entity_type::ALL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Iterators on mesh entity - begin. </p>

</div>
</div>
<a class="anchor" id="a7939f4b04c71f83a5a7fcf95c8ba1dba"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Portage::Flecsi_Mesh_Wrapper::ccw </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacePortage.html#a851c0332d789f5c3ca6c9ef50e375f25">Portage::Point2</a>&#160;</td>
          <td class="paramname"><em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacePortage.html#a851c0332d789f5c3ca6c9ef50e375f25">Portage::Point2</a>&#160;</td>
          <td class="paramname"><em>p2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacePortage.html#a851c0332d789f5c3ca6c9ef50e375f25">Portage::Point2</a>&#160;</td>
          <td class="paramname"><em>p3</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a28947e908619cf791f796bff12f647ea"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;long D&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Portage::Flecsi_Mesh_Wrapper::cell_centroid </td>
          <td>(</td>
          <td class="paramtype">int const&#160;</td>
          <td class="paramname"><em>cellid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPortage_1_1Point.html">Point</a>&lt; D &gt; *&#160;</td>
          <td class="paramname"><em>centroid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Centroid of a cell. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cellid</td><td>The ID of the cell. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">centroid</td><td>The vector of coordinates of the cell <code>cellid's</code> centroid. The length of the vector is equal to the dimension of the mesh. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4bcef35d48c6fcc9d9f4ab39adf0fa0e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;long D&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Portage::Flecsi_Mesh_Wrapper::cell_get_coordinates </td>
          <td>(</td>
          <td class="paramtype">int const&#160;</td>
          <td class="paramname"><em>cellid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classPortage_1_1Point.html">Portage::Point</a>&lt; D &gt;&gt; *&#160;</td>
          <td class="paramname"><em>pplist</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Templated version of coodinates of the nodes of a cell. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">D</td><td>The dimension of the mesh. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cellid</td><td>The ID of the cell. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">pplist</td><td>The vector of <a class="el" href="classPortage_1_1Point.html" title="Represents a point in an N-dimensional space. ">Portage::Point</a> objects containing the coordinates of a node. The length of the vector is equal to the number of nodes in the cell with ID <code>cellid</code>.</td></tr>
  </table>
  </dd>
</dl>
<p>Note: FleCSI Burton specialization doesn't currently fully support 1 or 3D. </p>

</div>
</div>
<a class="anchor" id="ab95a5cfaee2d9bbc2ad1d4a10bb5f367"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Portage::Flecsi_Mesh_Wrapper::cell_get_faces_and_dirs </td>
          <td>(</td>
          <td class="paramtype">int const&#160;</td>
          <td class="paramname"><em>cellid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int &gt; *&#160;</td>
          <td class="paramname"><em>cfaces</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int &gt; *&#160;</td>
          <td class="paramname"><em>cfdirs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get cell faces and the directions in which they are used. </p>

</div>
</div>
<a class="anchor" id="ab9f8430636c53f74ba452222e1555196"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Portage::Flecsi_Mesh_Wrapper::cell_get_node_adj_cells </td>
          <td>(</td>
          <td class="paramtype">int const&#160;</td>
          <td class="paramname"><em>cellid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacePortage.html#a650a8718a706648846a2915b90612849">Entity_type</a> const&#160;</td>
          <td class="paramname"><em>ptype</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int &gt; *&#160;</td>
          <td class="paramname"><em>adjcells</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get node connected neighbors of cell. </p>

</div>
</div>
<a class="anchor" id="a1e87b76dbd6397d966c733425f3f06e8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Portage::Flecsi_Mesh_Wrapper::cell_get_nodes </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>cellid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int &gt; *&#160;</td>
          <td class="paramname"><em>nodes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get list of nodes for a cell. </p>

</div>
</div>
<a class="anchor" id="a420667c6fbf0a061236b6cfd93c042ed"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double Portage::Flecsi_Mesh_Wrapper::cell_volume </td>
          <td>(</td>
          <td class="paramtype">int const&#160;</td>
          <td class="paramname"><em>cellID</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Cell area/volume. </p>

</div>
</div>
<a class="anchor" id="a38922699ba1245c3a358ad2112447973"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="namespacePortage.html#a851c0332d789f5c3ca6c9ef50e375f25">Portage::Point2</a>&gt; Portage::Flecsi_Mesh_Wrapper::cellToXY </td>
          <td>(</td>
          <td class="paramtype">int const&#160;</td>
          <td class="paramname"><em>cellID</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a144ce2ed51265dff13608f0fb16ec1c3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Portage::Flecsi_Mesh_Wrapper::decompose_cell_into_tets </td>
          <td>(</td>
          <td class="paramtype">int const&#160;</td>
          <td class="paramname"><em>cellID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::array&lt; <a class="el" href="namespacePortage.html#a991ba1823c1528ffe149889e79fb4450">Portage::Point3</a>, 4 &gt;&gt; *&#160;</td>
          <td class="paramname"><em>tcoords</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>planar_hex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="aaaafd607470b22e89cdcf5902144e894"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;long D&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Portage::Flecsi_Mesh_Wrapper::dual_cell_centroid </td>
          <td>(</td>
          <td class="paramtype">int const&#160;</td>
          <td class="paramname"><em>nodeid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPortage_1_1Point.html">Point</a>&lt; D &gt; *&#160;</td>
          <td class="paramname"><em>centroid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Centroid of a dual cell. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">nodeid</td><td>The ID of the node in the normal mesh / cell in the dual mesh. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">centroid</td><td>The vector of coordinates of the node in the normal mesh / the cell in the dual mesh with ID <code>nodeid</code>. The length of the vector is equal to the dimension of the mesh.</td></tr>
  </table>
  </dd>
</dl>
<p>NOTE: THIS IS ASSUMED TO BE THE NODE COORDINATE BECAUSE THE NODAL VARIABLES LIVE THERE, BUT FOR DISTORTED GRIDS, THE NODE COORDINATED MAY NOT BE THE CENTROID OF THE DUAL CELL </p>

</div>
</div>
<a class="anchor" id="ac6011a551dc74a57d28537399259926f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Portage::Flecsi_Mesh_Wrapper::dual_cell_get_coordinates </td>
          <td>(</td>
          <td class="paramtype">int const&#160;</td>
          <td class="paramname"><em>nodeid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespacePortage.html#a851c0332d789f5c3ca6c9ef50e375f25">Portage::Point2</a> &gt; *&#160;</td>
          <td class="paramname"><em>pplist</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>2D version of coords of nodes of a dual cell </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">nodeid</td><td>The ID of the node or dual cell in the dual mesh. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">pplist</td><td>The vector of <a class="el" href="classPortage_1_1Point.html" title="Represents a point in an N-dimensional space. ">Portage::Point</a> objects containing the coordinates of a node in the dual mesh / cell in the regular mesh. The length of the vector is equal to the number of nodes in the dual mesh cell with ID <code>nodeid</code>.</td></tr>
  </table>
  </dd>
</dl>
<p>The vertices are ordered CCW. For node <code>nodeid</code> not on a boundary, the vector <code>pplist</code> starts with a random vertex, but it is still ordered CCW. Use the <a class="el" href="test__flecsi__mesh__wrapper_8cc.html#a0538767ec31cbe4c8691d7f9eb52b846" title="Rotate the xylist vector into a canonical (unique) form. The first point will be the one with the low...">dual_cell_coordinates_canonical_rotation()</a> function to rotate the <code>pplist</code> into a canonical (unique) form.</p>
<p>worry about boundary cases </p>

</div>
</div>
<a class="anchor" id="a7a792dfa8d09e9ed42f77e0b731d8883"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Portage::Flecsi_Mesh_Wrapper::dual_cell_get_coordinates </td>
          <td>(</td>
          <td class="paramtype">int const&#160;</td>
          <td class="paramname"><em>nodeid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespacePortage.html#a991ba1823c1528ffe149889e79fb4450">Portage::Point3</a> &gt; *&#160;</td>
          <td class="paramname"><em>pplist</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>3D version of coords of nodes of a dual cell </p>

</div>
</div>
<a class="anchor" id="a47b8c6fbaa3f2c1b3a9e07e33782ad93"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Portage::Flecsi_Mesh_Wrapper::dual_cell_get_node_adj_cells </td>
          <td>(</td>
          <td class="paramtype">int const&#160;</td>
          <td class="paramname"><em>nodeid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacePortage.html#a650a8718a706648846a2915b90612849">Entity_type</a> const&#160;</td>
          <td class="paramname"><em>ptype</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int &gt; *&#160;</td>
          <td class="paramname"><em>adjnodes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get adjacent "dual cells" of a given "dual cell". </p>

</div>
</div>
<a class="anchor" id="ac8963a443e72966373a60503b2ace3fc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double Portage::Flecsi_Mesh_Wrapper::dual_cell_volume </td>
          <td>(</td>
          <td class="paramtype">int const&#160;</td>
          <td class="paramname"><em>nodeid</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Dual cell area/volume. </p>

</div>
</div>
<a class="anchor" id="ae157b4f064bc32db4f20eaed9c96223e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Portage::Flecsi_Mesh_Wrapper::dual_wedges_get_coordinates </td>
          <td>(</td>
          <td class="paramtype">int const&#160;</td>
          <td class="paramname"><em>nodeID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::array&lt; <a class="el" href="namespacePortage.html#a991ba1823c1528ffe149889e79fb4450">Portage::Point3</a>, 4 &gt;&gt; *&#160;</td>
          <td class="paramname"><em>wcoords</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a5eec2902830c76031fc7b1a3cdea51a1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacePortage.html#a9ad5b714018a06f725ef8f93b70fabe7">counting_iterator</a> Portage::Flecsi_Mesh_Wrapper::end </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacePortage.html#a762e851d5a6ada63ea496d767679cffb">Entity_kind</a> const&#160;</td>
          <td class="paramname"><em>entity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacePortage.html#a650a8718a706648846a2915b90612849">Entity_type</a> const&#160;</td>
          <td class="paramname"><em>etype</em> = <code>Entity_type::ALL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Iterator on mesh entity - end. </p>

</div>
</div>
<a class="anchor" id="a810e4400b333b9aa03c603fdf81d30a5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Portage::Flecsi_Mesh_Wrapper::face_get_nodes </td>
          <td>(</td>
          <td class="paramtype">int const&#160;</td>
          <td class="paramname"><em>faceid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int &gt; *&#160;</td>
          <td class="paramname"><em>fnodes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get nodes of a face. </p>

</div>
</div>
<a class="anchor" id="af3bff1ceb458fe85897c79764127657b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Portage::Flecsi_Mesh_Wrapper::get_global_id </td>
          <td>(</td>
          <td class="paramtype">int const&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacePortage.html#a762e851d5a6ada63ea496d767679cffb">Entity_kind</a> const&#160;</td>
          <td class="paramname"><em>kind</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get global id. </p>

</div>
</div>
<a class="anchor" id="a7ca2c3901e264cee5b9f64ba701f3554"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Portage::Flecsi_Mesh_Wrapper::node_get_cell_adj_nodes </td>
          <td>(</td>
          <td class="paramtype">int const&#160;</td>
          <td class="paramname"><em>nodeid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacePortage.html#a650a8718a706648846a2915b90612849">Entity_type</a> const&#160;</td>
          <td class="paramname"><em>ptype</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int &gt; *&#160;</td>
          <td class="paramname"><em>adjnodes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get "adjacent" nodes of given node. </p>
<p>Get "adjacent" nodes of given node - nodes that share a common cell with given node </p>

</div>
</div>
<a class="anchor" id="ab27331d45757a24db986172a27dfa47b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;long D&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Portage::Flecsi_Mesh_Wrapper::node_get_coordinates </td>
          <td>(</td>
          <td class="paramtype">int const&#160;</td>
          <td class="paramname"><em>nodeid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPortage_1_1Point.html">Portage::Point</a>&lt; D &gt; *&#160;</td>
          <td class="paramname"><em>pp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Templated version of coords of a node. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">D</td><td>The dimension of the mesh. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">nodeid</td><td>The ID of the node. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">pp</td><td>The <a class="el" href="classPortage_1_1Point.html" title="Represents a point in an N-dimensional space. ">Portage::Point</a> object containing the coordinate information.</td></tr>
  </table>
  </dd>
</dl>
<p>Note: FleCSI Burton specialization doesn't currently fully support 1 or 3D. </p>

</div>
</div>
<a class="anchor" id="ad7bc1c1f9ebd6bba8aa8de2a4f01b72a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Portage::Flecsi_Mesh_Wrapper::num_entities </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacePortage.html#a762e851d5a6ada63ea496d767679cffb">Entity_kind</a> const&#160;</td>
          <td class="paramname"><em>entity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacePortage.html#a650a8718a706648846a2915b90612849">Entity_type</a> const&#160;</td>
          <td class="paramname"><em>etype</em> = <code>Entity_type::ALL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Number of items of given entity. </p>

</div>
</div>
<a class="anchor" id="a243a74480861ec877eedb6a24c953736"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Portage::Flecsi_Mesh_Wrapper::num_ghost_cells </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Number of ghost cells in the mesh. </p>

</div>
</div>
<a class="anchor" id="a9875b7cb65fe13fc8b52a1e1ab1353ba"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Portage::Flecsi_Mesh_Wrapper::num_ghost_faces </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Number of ghost faces in the mesh. </p>

</div>
</div>
<a class="anchor" id="ab09f8baee178d83f1d9adb36c39e36e9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Portage::Flecsi_Mesh_Wrapper::num_ghost_nodes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Number of ghost nodes in the mesh. </p>

</div>
</div>
<a class="anchor" id="aa922df7274dda27dd499e1b30def9be5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Portage::Flecsi_Mesh_Wrapper::num_owned_cells </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Number of owned cells in the mesh. </p>

</div>
</div>
<a class="anchor" id="abbc606702094ec275d2f1100de05d124"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Portage::Flecsi_Mesh_Wrapper::num_owned_faces </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Number of owned faces in the mesh. </p>

</div>
</div>
<a class="anchor" id="ada2be83a48ee9e9e91ff46b9bc8d600d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Portage::Flecsi_Mesh_Wrapper::num_owned_nodes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Number of owned nodes in the mesh. </p>

</div>
</div>
<a class="anchor" id="a8d533122a6dae133507ef338061793fb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPortage_1_1Flecsi__Mesh__Wrapper.html">Flecsi_Mesh_Wrapper</a>&amp; Portage::Flecsi_Mesh_Wrapper::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPortage_1_1Flecsi__Mesh__Wrapper.html">Flecsi_Mesh_Wrapper</a> const &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assignment operator (disabled) </p>

</div>
</div>
<a class="anchor" id="a0fa1fcd29bec351e056e65f024d563e7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Portage::Flecsi_Mesh_Wrapper::order_wedges_ccw </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; int &gt; *&#160;</td>
          <td class="paramname"><em>wedgeids</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="af0e6e79b43ba1a5b03d2389dbf1c6317"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Portage::Flecsi_Mesh_Wrapper::space_dimension </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Dimension of space or mesh points. </p>

</div>
</div>
<a class="anchor" id="ae53adcd1032b21c68b9edd78869c151c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Portage::Flecsi_Mesh_Wrapper::wedges_get_coordinates </td>
          <td>(</td>
          <td class="paramtype">int const&#160;</td>
          <td class="paramname"><em>cellID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::array&lt; <a class="el" href="namespacePortage.html#a991ba1823c1528ffe149889e79fb4450">Portage::Point3</a>, 4 &gt;&gt; *&#160;</td>
          <td class="paramname"><em>wcoords</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/home/l280837/code/portage-gh/src/wrappers/mesh/flecsi/<a class="el" href="flecsi__mesh__wrapper_8h_source.html">flecsi_mesh_wrapper.h</a></li>
</ul>
</div><!-- contents -->
<!--
Copyright (c) 2016, Los Alamos National Security, LLC
All rights reserved.
Copyright 2016. Los Alamos National Security, LLC. This software was produced
under U.S. Government contract DE-AC52-06NA25396 for Los Alamos National
Laboratory (LANL), which is operated by Los Alamos National Security, LLC for
the U.S. Department of Energy. The U.S. Government has rights to use,
reproduce, and distribute this software.  NEITHER THE GOVERNMENT NOR LOS ALAMOS
NATIONAL SECURITY, LLC MAKES ANY WARRANTY, EXPRESS OR IMPLIED, OR ASSUMES ANY
LIABILITY FOR THE USE OF THIS SOFTWARE.  If software is modified to produce
derivative works, such modified software should be clearly marked, so as not to
confuse it with the version available from LANL.
Additionally, redistribution and use in source and binary forms, with or
without modification, are permitted provided that the following conditions are
met:
1. Redistributions of source code must retain the above copyright notice,
   this list of conditions and the following disclaimer.
2. Redistributions in binary form must reproduce the above copyright
   notice, this list of conditions and the following disclaimer in the
   documentation and/or other materials provided with the distribution.
3. Neither the name of Los Alamos National Security, LLC, Los Alamos
   National Laboratory, LANL, the U.S. Government, nor the names of its
   contributors may be used to endorse or promote products derived from this
   software without specific prior written permission.
THIS SOFTWARE IS PROVIDED BY LOS ALAMOS NATIONAL SECURITY, LLC AND
CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL LOS ALAMOS NATIONAL
SECURITY, LLC OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER
IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
POSSIBILITY OF SUCH DAMAGE.
-->
<!-- HTML footer for doxygen 1.8.8-->
<!-- start footer part -->
</div>
</div>
</div>
</div>
</div>
<!--<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address> -->
<footer id="footer" class="footer">
  <div class="container">
    <div class="row test-muted">
      <div class="footer-row col-md-6">Copyright &copy; 2016
	<a href="http://lanl.gov"> Los Alamos National Security, LLC</a>
	All Rights Reserved.
      </div>
      <div class="footer-row col-md-2">
	<a href="https://github.com/laristra/portage/blob/master/LICENSE">
	  BSD LICENSE
	</a>
      </div>
      <div class="footer-row col-md-2">
	LA-CC-16-084
      </div>
      <div class="footer-row col-md-1">
	<a href="mailto:portage@lanl.gov">
	  <i class="fa fa-envelope-o fa-2x"></i>
	</a>
      </div>
      <div class="footer-row col-md-1">
	<a href="https://github.com/laristra/portage">
	  <i class="fa fa-github fa-2x"></i>
	</a>
      </div>
    </div>
  </div>
</footer>
</body>
</html>
